<application>
  <component name="AppStorage">
    <histories>
      <item value="Unsatisfied Dependency Exception" />
      <item value="Base packages to scan for annotated components . {@ link # value ()} is an alias for ( and mutually exclusive with ) this attribute . Use {@ link # base Package Classes ()} for a type - safe alternative to String - based package names . /" />
      <item value="Annotation to activate Redis repositories . If no base package is configured through either {@ link # value ()}, {@ link # base Packages ()} or {@ link # base Package Classes ()} it will trigger scanning of the package of annotated class ." />
      <item value="store" />
      <item value="search Analyzer" />
      <item value="current type" />
      <item value="mapper [ id ] of different type , current type [ long ], merged type [ string ]" />
      <item value="merged type" />
      <item value="Allows post - processing of the bean factory in context subclasses ." />
      <item value="// Allows post - processing of the bean factory in context subclasses ." />
      <item value="pre Instantiate Singletons" />
      <item value="Trigger post - initialization callback for all applicable beans ..." />
      <item value="detect" />
      <item value="detect Handler Methods" />
      <item value="Implementation of Bean Factory interface" />
      <item value="put If Absent" />
      <item value="/ Whether the given type is a handler with handler methods . @ param bean Type the type of the bean being checked @ return &quot; true &quot; if this a handler type , &quot; false &quot; otherwise . / prote" />
      <item value="// JSR -330 API not available - Provider interface simply not supported then ." />
      <item value="// Java 8 not available - Optional references simply not supported then ." />
      <item value="Customize the {@ link Configurable Web Application Context } created by this Context Loader after config locations have been supplied to the context but before the context is &lt; em &gt; refreshed &lt;/ em &gt;. &lt; p &gt; The default implementation {@ linkplain # determine Context Initializer Classes ( Servlet Context ) determines } what ( if any ) context initializer classes have been specified through {@ linkplain # CONTEXT INITIALIZER CLASSES PARAM context init parameters } and {@ linkplain Application Context Initializer # initialize invokes each } with the given web application context . &lt; p &gt; Any {@ code Application Context Initializers } implementing {@ link org . springframework . core . Ordered Ordered } or marked with @{@ link org . springframework . core . annotation . Order Order } will be sorted appropriately ." />
      <item value="is Active" />
      <item value="The context has not yet been refreshed -&gt; provide services such as // setting the parent context , setting the application context id , etc" />
      <item value="Reflection Utils" />
      <item value="get Declared Constructor" />
      <item value="instantiate Class" />
      <item value="load Bean Definitions" />
      <item value="Initialize the bean definition reader used for loading the bean definitions of this context . Default implementation is empty . &lt; p &gt; Can be overridden in subclasses , e . g . for turning off XML validation or using a different Xml Bean Definition Parser implementation ." />
      <item value="The config location defaults can be overridden via the &quot; context Config Location &quot; context - param of {@ link org . springframework . web . context . Context Loader } and servlet init - param of {@ link org . springframework . web . servlet . Framework Servlet }. Config locations can either denote concrete files like &quot;/ WEB - INF / context . xml &quot; or Ant - style patterns like &quot;/ WEB - INF / - context . xml &quot; ( see {@ link org . springframework . util . Path Matcher } javadoc for pattern details )." />
      <item value="&lt; p &gt; By default , the configuration will be taken from &quot;/ WEB - INF / application Context . xml &quot; for the root context , and &quot;/ WEB - INF / test - servlet . xml &quot; for a context with the namespace &quot; test - servlet &quot; ( like for a Dispatcher Servlet instance with the servlet - name &quot; test &quot;)." />
      <item value="/ {@ link org . springframework . web . context . Web Application Context } implementation which takes its configuration from XML documents , understood by an {@ link org . springframework . beans . factory . xml . Xml Bean Definition Reader }. This is essentially the equivalent of {@ link org . springframework . context . support . Generic Xml Application Context } for a web environment . &lt; p &gt; By default , the configuration will be taken from &quot;/ WEB - INF / application Context . xml &quot; for the root context , and &quot;/ WEB - INF / test - servlet . xml &quot; for a context with the namespace &quot; test - servlet &quot; ( like for a Dispatcher Servlet instance with the servlet - name &quot; test &quot;). &lt; p &gt; The config location defaults can be overridden via the &quot; context Config Location &quot; context - param of {@ link org . springframework . web . context . Context Loader } and servlet init - param of {@ link org . springframework . web . servlet . Framework Servlet }. Config locations can either denote concrete files like &quot;/ WEB - INF / context . xml &quot; or Ant - style patterns like &quot;/ WEB - INF / - context . xml &quot; ( see {@ link org . springframework . util . Path Matcher } javadoc for pattern details ). &lt; p &gt; Note : In case of multiple config locations , later bean definitions will override ones defined in earlier loaded files . This can be leveraged to deliberately override certain bean definitions via an extra XML file . &lt; p &gt;&lt; b &gt; For a Web Application Context that reads in a different bean definition format , create an analogous subclass of {@ link Abstract Refreshable Web Application Context }.&lt;/ b &gt; Such a context implementation can be specified as &quot; context Class &quot; context - param for Context Loader or &quot; context Class &quot; init - param for Framework Servlet . @ author Rod Johnson @ author Juergen Hoeller @ see # set Namespace @ see # set Config Locations @ see org . springframework . beans . factory . xml . Xml Bean Definition Reader @ see org . springframework . web . context . Context Loader # init Web Application Context @ see org . springframework . web . servlet . Framework Servlet # init Web Application Context /" />
      <item value="Pseudo URL prefix for all matching resources from the class path : &quot; classpath :&quot; This differs from Resource Loader ' s classpath URL prefix in that it retrieves all matching resources for a given name ( e . g . &quot;/ beans . xml &quot;), for example in the root of all deployed JAR files ." />
      <item value="/ Pseudo URL prefix for all matching resources from the class path : &quot; classpath :&quot; This differs from Resource Loader ' s classpath URL prefix in that it retrieves all matching resources for a given name ( e . g . &quot;/ beans . xml &quot;), for example in the root of all deployed JAR files . @ see org . springframework . core . io . Resource Loader # CLASSPATH URL PREFIX /" />
      <item value="Load or refresh the persistent representation of the configuration , which might an XML file , properties file , or relational database schema . &lt; p &gt; As this is a startup method , it should destroy already created singletons if it fails , to avoid dangling resources . In other words , after invocation of that method , either all or no singletons at all should be instantiated . @ throws Beans Exception if the bean factory could not be initialized @ throws Illegal State Exception if already initialized and multiple refresh attempts are not supported" />
      <item value="/ Load or refresh the persistent representation of the configuration , which might an XML file , properties file , or relational database schema . &lt; p &gt; As this is a startup method , it should destroy already created singletons if it fails , to avoid dangling resources . In other words , after invocation of that method , either all or no singletons at all should be instantiated . @ throws Beans Exception if the bean factory could not be initialized @ throws Illegal State Exception if already initialized and multiple refresh attempts are not supported /" />
      <item value="initialize fence and size on first use" />
      <item value="spliterators" />
      <item value="Spliter" />
      <item value="Spliterat" />
      <item value="Value Spliterator" />
      <item value="Spliterator" />
      <item value="pliterator" />
      <item value="tab" />
      <item value="evict false when initially constructing this map , else true ( relayed to method after Node Insertion )." />
      <item value="/ Computes key . hash Code () and spreads ( XO Rs ) higher bits of hash to lower . Because the table uses power - of - two masking , sets of hashes that vary only in bits above the current mask will always collide . ( Among known examples are sets of Float keys holding consecutive whole numbers in small tables .) So we apply a transform that spreads the impact of higher bits downward . There is a tradeoff between speed , utility , and quality of bit - spreading . Because many common sets of hashes are already reasonably distributed ( so don ' t benefit from spreading ), and because we use trees to handle large sets of collisions in bins , we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage , as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds . /" />
      <item value="XO Rs" />
      <item value="spreads" />
      <item value="Computes" />
      <item value="Static utilities" />
      <item value="MIN TREEIFY CAPACITY" />
      <item value="TREEIFY" />
    </histories>
  </component>
</application>