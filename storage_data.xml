<application>
  <component name="AppStorage">
    <histories>
      <item value="SERIALIZABLE" />
      <item value="REPEATABLE READ" />
      <item value="READ UNCOMMITTED" />
      <item value="READ COMMITTED" />
      <item value="NONE" />
      <item value="TRANSACTION READ COMMITTED" />
      <item value="TRANSACTION NONE" />
      <item value="Interceptor" />
      <item value="Too many connections" />
      <item value="message from server" />
      <item value="Data source rejected establishment of connection" />
      <item value="a commit / rollback before calling close ()" />
      <item value="force commit even on non - dirty sessions because some databases require" />
      <item value="Simple cache manager working against a given collection of caches . Useful for testing or simple caching declarations ." />
      <item value="if loading the config file failed" />
      <item value="The default implementation uses the standard My Batis" />
      <item value="Build a {@ code Sql Session Factory } instance ." />
      <item value="issue #117 read properties first" />
      <item value="product Name" />
      <item value="no match , return null" />
      <item value="Vendor Database Id provider" />
      <item value="Vendor Database Id provider It returns database product name as a database Id If the user provides a properties it uses it to translate database product name key =&quot; Microsoft SQL Server &quot;, value =&quot; ms &quot; will return &quot; ms &quot; It can return null , if no database product name or a properties was specified and no translation was found /" />
      <item value="Result Handler" />
      <item value="Executor" />
      <item value="state" />
      <item value="&lt; b &gt; NOTE :&lt;/ b &gt; This class &lt; em &gt; overrides &lt;/ em &gt; any {@ code Environment } you have set in the My Batis config file . This is used only as a placeholder name . The default value is {@ code Sql Session Factory Bean . class . get Simple Name ()}." />
      <item value="trade" />
      <item value="sandzhang" />
      <item value="3 seconds is slow sql" />
      <item value="hexianmao" />
      <item value="For IBM JDK , 原因请看解密方法中的说明" />
      <item value="判断是否需要解密，如果需要就进行解密行动" />
      <item value="A Consumer Factory must be provided" />
      <item value="lock Interruptibly" />
      <item value="szujobs" />
      <item value="ljw 2083" />
      <item value="ljw 2083@ alibaba - inc . com" />
      <item value="Not allowed to update a Null Cache Key instance ." />
      <item value="Executing prepared SQL query" />
      <item value="Resource Transaction Manager" />
      <item value="Platform" />
      <item value="&lt; p &gt; Application code is required to retrieve the JDBC Connection via {@ link Data Source Utils # get Connection ( Data Source )} instead of a standard J 2 EE - style {@ link Data Source # get Connection ()} call . Spring classes such as {@ link org . springframework . jdbc . core . Jdbc Template } use this strategy implicitly . If not used in combination with this transaction manager , the {@ link Data Source Utils } lookup strategy behaves exactly like the native Data Source lookup ; it can thus be used in a portable fashion ." />
      <item value="&lt; p &gt;&lt; b &gt; Note : The Data Source that this transaction manager operates on needs to return independent Connections .&lt;/ b &gt; The Connections may come from a pool ( the typical case ), but the Data Source must not return thread - scoped / request - scoped Connections or the like . This transaction manager will associate Connections with thread - bound transactions itself , according to the specified propagation behavior . It assumes that a separate , independent Connection can be obtained even during an ongoing transaction ." />
      <item value="@ link org . springframework . transaction . Platform Transaction Manager } implementation for a single JDBC {@ link javax . sql . Data Source }. This class is capable of working in any environment with any JDBC driver , as long as the setup uses a {@ code javax . sql . Data Source } as its {@ code Connection } factory mechanism . Binds a JDBC Connection from the specified Data Source to the current thread , potentially allowing for one thread - bound Connection per Data Source ." />
      <item value="do Suspend" />
      <item value="Bind the session holder to the thread ." />
      <item value="determine Timeout" />
      <item value="set Transaction Active" />
      <item value="for example if we ' ve explicitly // configured the connection pool to set it already" />
      <item value="unnecessarily" />
      <item value="ambiguous" />
      <item value="select By Order Id is ambiguous in Mapped Statements collection" />
      <item value="divide" />
    </histories>
  </component>
</application>