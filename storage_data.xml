<application>
  <component name="AppStorage">
    <histories>
      <item value="issue #117 read properties first" />
      <item value="product Name" />
      <item value="no match , return null" />
      <item value="Vendor Database Id provider" />
      <item value="Vendor Database Id provider It returns database product name as a database Id If the user provides a properties it uses it to translate database product name key =&quot; Microsoft SQL Server &quot;, value =&quot; ms &quot; will return &quot; ms &quot; It can return null , if no database product name or a properties was specified and no translation was found /" />
      <item value="Result Handler" />
      <item value="Executor" />
      <item value="state" />
      <item value="&lt; b &gt; NOTE :&lt;/ b &gt; This class &lt; em &gt; overrides &lt;/ em &gt; any {@ code Environment } you have set in the My Batis config file . This is used only as a placeholder name . The default value is {@ code Sql Session Factory Bean . class . get Simple Name ()}." />
      <item value="trade" />
      <item value="sandzhang" />
      <item value="3 seconds is slow sql" />
      <item value="hexianmao" />
      <item value="For IBM JDK , 原因请看解密方法中的说明" />
      <item value="判断是否需要解密，如果需要就进行解密行动" />
      <item value="A Consumer Factory must be provided" />
      <item value="lock Interruptibly" />
      <item value="szujobs" />
      <item value="ljw 2083" />
      <item value="ljw 2083@ alibaba - inc . com" />
      <item value="Not allowed to update a Null Cache Key instance ." />
      <item value="Executing prepared SQL query" />
      <item value="Resource Transaction Manager" />
      <item value="Platform" />
      <item value="&lt; p &gt; Application code is required to retrieve the JDBC Connection via {@ link Data Source Utils # get Connection ( Data Source )} instead of a standard J 2 EE - style {@ link Data Source # get Connection ()} call . Spring classes such as {@ link org . springframework . jdbc . core . Jdbc Template } use this strategy implicitly . If not used in combination with this transaction manager , the {@ link Data Source Utils } lookup strategy behaves exactly like the native Data Source lookup ; it can thus be used in a portable fashion ." />
      <item value="&lt; p &gt;&lt; b &gt; Note : The Data Source that this transaction manager operates on needs to return independent Connections .&lt;/ b &gt; The Connections may come from a pool ( the typical case ), but the Data Source must not return thread - scoped / request - scoped Connections or the like . This transaction manager will associate Connections with thread - bound transactions itself , according to the specified propagation behavior . It assumes that a separate , independent Connection can be obtained even during an ongoing transaction ." />
      <item value="@ link org . springframework . transaction . Platform Transaction Manager } implementation for a single JDBC {@ link javax . sql . Data Source }. This class is capable of working in any environment with any JDBC driver , as long as the setup uses a {@ code javax . sql . Data Source } as its {@ code Connection } factory mechanism . Binds a JDBC Connection from the specified Data Source to the current thread , potentially allowing for one thread - bound Connection per Data Source ." />
      <item value="do Suspend" />
      <item value="Bind the session holder to the thread ." />
      <item value="determine Timeout" />
      <item value="set Transaction Active" />
      <item value="for example if we ' ve explicitly // configured the connection pool to set it already" />
      <item value="unnecessarily" />
      <item value="expensive" />
      <item value="// Switch to manual commit if necessary . This is very expensive in some JDBC drivers , // so we don ' t want to do it unnecessarily ( for example if we ' ve explicitly // configured the connection pool to set it already )." />
      <item value="previous Isolation Level" />
      <item value="is Existing Transaction" />
      <item value="Return whether nested transactions are allowed ." />
      <item value="// If we got a Transaction Aware Data Source Proxy , we need to perform transactions // for its underlying target Data Source , else data access code won ' t see // properly exposed transactions ( i . e . transactions for the target Data Source )." />
      <item value="// Silently ignores autocommit and isolation level , as managed transactions are entirely // controlled by an external manager . It ' s silently ignored so that // code remains portable between managed and unmanaged configurations ." />
      <item value="controlled by an external manager . It ' s silently ignored so that" />
      <item value="Silently ignores autocommit and isolation level , as managed transactions are entirely" />
      <item value="force commit even on non - dirty sessions because some databases require" />
      <item value="a commit / rollback before calling close ()" />
      <item value="Note : The Data Source used by the Environment should be synchronized with the // transaction either through Data Source Tx Mgr or another tx synchronization . // Further assume that if an exception is thrown , whatever started the transaction will // handle closing / rolling back the Connection associated with the Sql Session ." />
      <item value="active" />
      <item value="synchronization" />
      <item value="holder" />
      <item value="Register" />
      <item value="Register session holder if synchronization is active ( i . e . a Spring TX is active )" />
      <item value="Alias Query is useful for creating new alias or deleting existing ones" />
      <item value="Criteria" />
      <item value="ambiguous" />
      <item value="select By Order Id is ambiguous in Mapped Statements collection" />
      <item value="divide" />
    </histories>
  </component>
</application>