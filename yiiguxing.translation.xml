<application>
  <component name="AppStorage">
    <histories>
      <item value="Add a list of servers to the 'allServer' list; does not verify * uniqueness, so you could give a server a greater share by adding it more * than once USED by Test Cases only for legacy reason. DO NOT USE!!" />
      <item value="cross associate with each other" />
      <item value="i.e. Rule,Ping meet your container LB" />
      <item value="LB, these are your Ping and Rule guys ..." />
      <item value="compliant value" />
      <item value="the initial delay in milliseconds as a String value, e.g. a placeholder" />
      <item value="Number of milliseconds to delay before the first execution of a" />
      <item value="the initial delay in milliseconds" />
      <item value="initial Delay" />
      <item value="trace" />
      <item value="Log a message at the TRACE level according to the specified format * and arguments. * &lt;p/&gt; * &lt;p&gt;This form avoids superfluous object creation when the logger * is disabled for the TRACE level. &lt;/p&gt;" />
      <item value="NOTE: IFF we were doing a real ping // assuming we had a large set of servers (say 15) // the logic below will run them serially // hence taking 15 times the amount of time it takes // to ping each server // A better method would be to put this in an executor // pool // But, at the time of this writing, we dont REALLY // use a Real Ping (its mostly in memory eureka call) // hence we can afford to simplify this design and run // this // serially" />
      <item value="Default answer is DEAD." />
      <item value="LoadBalancer: PingTask executing [{}] servers configured" />
      <item value="Load Balancer" />
      <item value="Candidates" />
      <item value="num Candidates" />
      <item value="I Ping Strategy" />
      <item value="ping Strategy" />
      <item value="Executor service for executing asynchronous requests." />
      <item value="ffordance to change the URI we connect to while &quot;priming&quot; // default of &quot;/&quot; is good for most - but if its heavy operation on // the server side, then a more lightweight URI can be chosen" />
      <item value="Prime Connection End Stats" />
      <item value="Prime the connections for a given Client (For those Client that * have a LoadBalancer that knows the set of Servers it will connect to) This is * mainly done to address those deployment environments (Read EC2) which benefit * from a firewall connection/path warmup prior to actual use for live requests. * &lt;p&gt; * This class is not protocol specific. Actual priming operation is delegated to * instance of {@link IPrimeConnection}, which is instantiated using reflection * according to property {@link CommonClientConfigKey#PrimeConnectionsClassName}." />
      <item value="get All Servers" />
      <item value="get Reachable Servers" />
      <item value="Only the servers that are up and reachable." />
      <item value="A Query that matches documents containing a term." />
      <item value="A Query that matches documents matching boolean combinations of other queries." />
      <item value="Failed to decode '_id'. readString can only be called when CurrentBSONType is STRING, not when CurrentBSONType is OBJECT_ID." />
      <item value="A custom Codec or PojoCodec may need to be explicitly configured and registered to handle this type." />
      <item value="Binary Operator" />
      <item value="a merge function, used to resolve collisions between * values associated with the same key, as supplied * to {@link Map#merge(Object, Object, BiFunction)}" />
      <item value="map Merger" />
      <item value="merge Function" />
      <item value="register the rule as it contains metric for available servers count" />
      <item value="This abstraction provides a wrapped mechanism to manage those runtime * shutdown hooks." />
      <item value="Apparently, adding a runtime shutdown hook will create a global reference * which can cause memory leaks if not cleaned up." />
      <item value="ShutdownEnabledTimer class handles runtime shutdown issues." />
      <item value="A basic implementation of the load balancer where an arbitrary list of * servers can be set as the server pool. A ping can be set to determine the * liveness of a server. Internally, this class maintains an &quot;all&quot; server list * and an &quot;up&quot; server list and use them depending on what the caller asks for." />
      <item value="Round Robin Rule" />
      <item value="DEFAULT RULE" />
      <item value="AbstractLoadBalancer contains features required for most loadbalancing * implementations. * * An anatomy of a typical LoadBalancer consists of 1. A List of Servers (nodes) * that are potentially bucketed based on a specific criteria. 2. A Class that * defines and implements a LoadBalacing Strategy via &lt;code&gt;IRule&lt;/code&gt; 3. A * Class that defines and implements a mechanism to determine the * suitability/availability of the nodes/servers in the List." />
      <item value="List of servers that this Loadbalancer knows about" />
      <item value="delegate to {@link #chooseServer(Object)} with parameter null." />
      <item value="Initial list of servers. * This API also serves to add additional ones at a later time * The same logical server (host:port) could essentially be added multiple times * (helpful in cases where you want to give more &quot;weightage&quot; perhaps ..)" />
      <item value="Interface that defines the operations for a software loadbalancer. A typical * loadbalancer minimally need a set of servers to loadbalance for, a method to * mark a particular server to be out of rotation and a call that will choose a * server from the existing list of server." />
      <item value="Choose a server from load balancer." />
      <item value="Implementation of BeanDefinitionRegistry interface" />
      <item value="TODO: better handling of key" />
      <item value="for backwards compatibility" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1251" />
        <entry key="ENGLISH" value="1252" />
        <entry key="ARABIC" value="1" />
        <entry key="IRISH" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="DANISH" value="2" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="5" />
        <entry key="CATALAN" value="2" />
        <entry key="CORSICAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="4" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="2" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="1" />
        <entry key="SUNDANESE" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>