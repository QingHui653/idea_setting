<application>
  <component name="AppStorage">
    <histories>
      <item value="count Name" />
      <item value="name" />
      <item value="native Query" />
      <item value="wsy" />
      <item value="search" />
      <item value="get Total Pages" />
      <item value="page" />
      <item value="get Total Elements" />
      <item value="is Reply" />
      <item value="btn Show" />
      <item value="table Params" />
      <item value="order" />
      <item value="refund" />
      <item value="reconciliation Refund" />
      <item value="laiyd" />
      <item value="To Match Scale" />
      <item value="Strip" />
      <item value="Immutable, arbitrary-precision signed decimal numbers. A * {@code BigDecimal} consists of an arbitrary precision integer * &lt;i&gt;unscaled value&lt;/i&gt; and a 32-bit integer &lt;i&gt;scale&lt;/i&gt;. If zero * or positive, the scale is the number of digits to the right of the * decimal point. If negative, the unscaled value of the number is * multiplied by ten to the power of the negation of the scale. The * value of the number represented by the {@code BigDecimal} is * therefore &lt;tt&gt;(unscaledValue &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;." />
      <item value="&lt;p&gt;The {@code BigDecimal} class provides operations for * arithmetic, scale manipulation, rounding, comparison, hashing, and * format conversion. The {@link #toString} method provides a * canonical representation of a {@code BigDecimal}. *" />
      <item value="Immutable, arbitrary-precision signed decimal numbers. A * {@code BigDecimal} consists of an arbitrary precision integer * &lt;i&gt;unscaled value&lt;/i&gt; and a 32-bit integer &lt;i&gt;scale&lt;/i&gt;. If zero * or positive, the scale is the number of digits to the right of the * decimal point. If negative, the unscaled value of the number is * multiplied by ten to the power of the negation of the scale. The * value of the number represented by the {@code BigDecimal} is * therefore &lt;tt&gt;(unscaledValue &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;. * * &lt;p&gt;The {@code BigDecimal} class provides operations for * arithmetic, scale manipulation, rounding, comparison, hashing, and * format conversion. The {@link #toString} method provides a * canonical representation of a {@code BigDecimal}." />
      <item value="A class used to represent multiprecision integers that makes efficient * use of allocated space by allowing a number to occupy only part of * an array so that the arrays do not have to be reallocated as often. * When performing an operation with many iterations the array used to * hold a number is only reallocated when necessary and does not have to * be the same size as the number it represents. A mutable number allows * calculations to occur on the same number without having to create * a new number for every step of the calculation as occurs with * BigIntegers." />
      <item value="Immutable objects which encapsulate the context settings which * describe certain rules for numerical operators, such as those * implemented by the {@link BigDecimal} class." />
      <item value="A simple bit sieve used for finding prime number candidates. Allows setting * and clearing of bits in a storage array. The size of the sieve is assumed to * be constant to reduce overhead. All the bits of a new bitSieve are zero, and * bits are removed from it by setting them." />
      <item value="is Export" />
      <item value="Makes available the permit for the given thread, if it * was not already available. If the thread was blocked on * {@code park} then it will unblock. Otherwise, its next call * to {@code park} is guaranteed not to block. This operation * is not guaranteed to have any effect at all if the given * thread has not been started." />
      <item value="Even though volatile, hotspot doesn't need a write barrier here." />
      <item value="&lt;p&gt;This class associates, with each thread that uses it, a permit * (in the sense of the {@link java.util.concurrent.Semaphore * Semaphore} class). A call to {@code park} will return immediately * if the permit is available, consuming it in the process; otherwise * it &lt;em&gt;may&lt;/em&gt; block. A call to {@code unpark} makes the permit * available, if it was not already available. (Unlike with Semaphores * though, permits do not accumulate. There is at most one.)" />
      <item value="Basic thread blocking primitives for creating locks and other * synchronization classes." />
      <item value="gnore interrupts while waiting" />
      <item value="&lt;dt&gt;&lt;b&gt;&lt;i&gt;Fair mode&lt;/i&gt;&lt;/b&gt; * &lt;dd&gt;When constructed as fair, threads contend for entry using an * approximately arrival-order policy. When the currently held lock * is released, either the longest-waiting single writer thread will * be assigned the write lock, or if there is a group of reader threads * waiting longer than all waiting writer threads, that group will be * assigned the read lock." />
      <item value="&lt;dt&gt;&lt;b&gt;&lt;i&gt;Non-fair mode (default)&lt;/i&gt;&lt;/b&gt; * &lt;dd&gt;When constructed as non-fair (the default), the order of entry * to the read and write lock is unspecified, subject to reentrancy * constraints. A nonfair lock that is continuously contended may * indefinitely postpone one or more reader or writer threads, but * will normally have higher throughput than a fair lock." />
      <item value="&lt;p&gt;This class does not impose a reader or writer preference * ordering for lock access. However, it does support an optional * &lt;em&gt;fairness&lt;/em&gt; policy." />
      <item value="An implementation of {@link ReadWriteLock} supporting similar * semantics to {@link ReentrantLock}. * &lt;p&gt;This class has the following properties:" />
      <item value="Synchronization implementation for ReentrantReadWriteLock. * Subclassed into fair and nonfair versions." />
      <item value="nonfair" />
      <item value="Returns the lock used for writing." />
      <item value="Returns the lock used for reading." />
      <item value="&lt;p&gt;Before waiting on the condition the lock must be held by the * current thread. * A call to {@link Condition#await()} will atomically release the lock * before waiting and re-acquire the lock before the wait returns." />
      <item value="Returns a new {@link Condition} instance that is bound to this * {@code Lock} instance." />
      <item value="interrupted" />
      <item value="Acquires the lock unless the current thread is * {@linkplain Thread#interrupt interrupted}." />
      <item value="Acquires the lock unless the current thread is" />
      <item value="&lt;p&gt;A {@code Lock} implementation may be able to detect erroneous use * of the lock, such as an invocation that would cause deadlock, and * may throw an (unchecked) exception in such circumstances. The * circumstances and the exception type must be documented by that * {@code Lock} implementation." />
      <item value="A {@code Lock} implementation may be able to detect erroneous use * of the lock, such as an invocation that would cause deadlock, and * may throw an (unchecked) exception in such circumstances. The * circumstances and the exception type must be documented by that * {@code Lock} implementation." />
      <item value="erroneous" />
      <item value="detect" />
      <item value="Implementation Considerations" />
      <item value="&lt;p&gt;If the lock is not available then the current thread becomes * disabled for thread scheduling purposes and lies dormant until the * lock has been acquired." />
      <item value="&lt;p&gt;As interruption generally implies cancellation, and checks for * interruption are often infrequent, an implementation can favor responding * to an interrupt over normal method return. This is true even if it can be * shown that the interrupt occurred after another action may have unblocked * the thread. An implementation should document this behavior." />
      <item value="&lt;p&gt;The three forms of lock acquisition (interruptible, * non-interruptible, and timed) may differ in their performance * characteristics, ordering guarantees, or other implementation * qualities. Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt; * acquisition of a lock may not be available in a given {@code Lock} * class. Consequently, an implementation is not required to define * exactly the same guarantees or semantics for all three forms of * lock acquisition, nor is it required to support interruption of an * ongoing lock acquisition. An implementation is required to clearly * document the semantics and guarantees provided by each of the * locking methods. It must also obey the interruption semantics as * defined in this interface, to the extent that interruption of lock * acquisition is supported: which is either totally, or only on * method entry." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="387" />
        <entry key="ENGLISH" value="387" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CORSICAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>