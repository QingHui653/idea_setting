<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="export an stub service for dispaching event" />
      <item value="dispaching" />
      <item value="event" />
      <item value="stub" />
      <item value="Key" />
      <item value="service" />
      <item value="service Key" />
      <item value="export service." />
      <item value="Protocol" />
      <item value="the resulting byte size of encoding is" />
      <item value="TODO modified by lishen" />
      <item value="Invoke the given target via reflection, as part of an AOP method invocation." />
      <item value="Reflection" />
      <item value="Joinpoint" />
      <item value="invoke" />
      <item value="OPTTYPE" />
      <item value="DELETE" />
      <item value="OPTTYPE DELETE" />
      <item value="optimize Serialization" />
      <item value="injvm" />
      <item value="more than 1 default extension name on extension" />
      <item value="DUBBO INTERNAL DIRECTORY" />
      <item value="is Invalid Local Host" />
      <item value="anyhost" />
      <item value="is Primitive" />
      <item value="legacy Properties" />
      <item value="check Stub And Mock" />
      <item value="deprecated" />
      <item value="服务是否已经 deprecated" />
      <item value="Expected method. item.processTime?string evaluated instead to freemarker.template.SimpleScalar" />
      <item value="to" />
      <item value="instead" />
      <item value="evaluated" />
      <item value="?string evaluated instead to freemarker.template.SimpleScalar" />
      <item value="escape" />
      <item value="Bulletin Board" />
      <item value="No qualifying bean of type [com.ivyb2b.oms.stock.service.IInoutListService] is defined: expected single matching bean but found 2: inoutListServiceImpl,InoutListService" />
      <item value="source" />
      <item value="on Release" />
      <item value="on Scrolling" />
      <item value="scroll It" />
      <item value="on Pulling" />
      <item value="partner" />
      <item value="PATTERN NAME" />
      <item value="Abstract Bean Definition Parser" />
      <item value="a tiny implementation of Promises/A+." />
      <item value="org.springframework.transaction.PlatformTransactionManager implementation for a single JDBC DataSource. This class is capable of working in any environment with any JDBC driver, as long as the setup uses a javax.sql.DataSource as its Connection factory mechanism. Binds a JDBC Connection from the specified DataSource to the current thread, potentially allowing for one thread-bound Connection per DataSource. Note: The DataSource that this transaction manager operates on needs to return independent Connections. The Connections may come from a pool (the typical case), but the DataSource must not return thread-scoped / request-scoped Connections or the like. This transaction manager will associate Connections with thread-bound transactions itself, according to the specified propagation behavior. It assumes that a separate, independent Connection can be obtained even during an ongoing transaction. Application code is required to retrieve the JDBC Connection via DataSourceUtils.getConnection(DataSource) instead of a standard J2EE-style DataSource.getConnection() call. Spring classes such as org.springframework.jdbc.core.JdbcTemplate use this strategy implicitly. If not used in combination with this transaction manager, the DataSourceUtils lookup strategy behaves exactly like the native DataSource lookup; it can thus be used in a portable fashion. Alternatively, you can allow application code to work with the standard J2EE-style lookup pattern DataSource.getConnection(), for example for legacy code that is not aware of Spring at all. In that case, define a TransactionAwareDataSourceProxy for your target DataSource, and pass that proxy DataSource to your DAOs, which will automatically participate in Spring-managed transactions when accessing it. Supports custom isolation levels, and timeouts which get applied as appropriate JDBC statement timeouts. To support the latter, application code must either use org.springframework.jdbc.core.JdbcTemplate, call DataSourceUtils.applyTransactionTimeout for each created JDBC Statement, or go through a TransactionAwareDataSourceProxy which will create timeout-aware JDBC Connections and Statements automatically. Consider defining a LazyConnectionDataSourceProxy for your target DataSource, pointing both this transaction manager and your DAOs to it. This will lead to optimized handling of &quot;empty&quot; transactions, i.e. of transactions without any JDBC statements executed. A LazyConnectionDataSourceProxy will not fetch an actual JDBC Connection from the target DataSource until a Statement gets executed, lazily applying the specified transaction settings to the target Connection. This transaction manager supports nested transactions via the JDBC 3.0 java.sql.Savepoint mechanism. The &quot;nestedTransactionAllowed&quot; flag defaults to &quot;true&quot;, since nested transactions will work without restrictions on JDBC drivers that support savepoints (such as the Oracle JDBC driver). This transaction manager can be used as a replacement for the org.springframework.transaction.jta.JtaTransactionManager in the single resource case, as it does not require a container that supports JTA, typically in combination with a locally defined JDBC DataSource (e.g. an Apache Commons DBCP connection pool). Switching between this local strategy and a JTA environment is just a matter of configuration!" />
      <item value="Property 'dataSource' is required&quot;" />
      <item value="Abstract base class that implements Spring's standard transaction workflow, serving as basis for concrete platform transaction managers like org.springframework.transaction.jta.JtaTransactionManager. This base class provides the following workflow handling: determines if there is an existing transaction; applies the appropriate propagation behavior; suspends and resumes transactions if necessary; checks the rollback-only flag on commit; applies the appropriate modification on rollback (actual rollback or setting rollback-only); triggers registered synchronization callbacks (if transaction synchronization is active). Subclasses have to implement specific template methods for specific states of a transaction, e.g.: begin, suspend, resume, commit, rollback. The most important of them are abstract and must be provided by a concrete implementation; for the rest, defaults are provided, so overriding is optional. Transaction synchronization is a generic mechanism for registering callbacks that get invoked at transaction completion time. This is mainly used internally by the data access support classes for JDBC, Hibernate, JPA, etc when running within a JTA transaction: They register resources that are opened within the transaction for closing at transaction completion time, allowing e.g. for reuse of the same Hibernate Session within the transaction. The same mechanism can also be leveraged for custom synchronization needs in an application. The state of this class is serializable, to allow for serializing the transaction strategy along with proxies that carry a transaction interceptor. It is up to subclasses if they wish to make their state to be serializable too. They should implement the java.io.Serializable marker interface in that case, and potentially a private readObject() method (according to Java serialization rules) if they need to restore any transient state." />
      <item value="Exception thrown when an operation is attempted that * relies on an existing transaction (such as setting * rollback status) and there is no existing transaction. * This represents an illegal usage of the transaction API. *" />
    </histories>
  </component>
</application>