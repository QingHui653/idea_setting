<application>
  <component name="AppStorage">
    <histories>
      <item value="find By Condition" />
      <item value="The iteration ordering method for this linked hash map:" />
      <item value="&lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order." />
      <item value="for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order." />
      <item value="The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;" />
      <item value="The head of the doubly linked list." />
      <item value="Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)" />
      <item value="Comparator" />
      <item value="Tree Map" />
      <item value="comparator the comparator that will be used to order this map." />
      <item value="insertion-order" />
      <item value="access-order" />
      <item value="Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode." />
      <item value="the ordering mode" />
      <item value="the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for" />
      <item value="Dummy value to associate with an Object in the backing Map" />
      <item value="ignored (distinguishes this * constructor from other int, float constructor.)" />
      <item value="dummy" />
      <item value="initial Capacity" />
      <item value="Compares two keys using the correct comparison method for this TreeMap." />
      <item value="funding Company Id" />
      <item value="overrides of HashMap hook methods" />
      <item value="Transfers all entries to new table array. This method is called * by superclass resize. It is overridden for performance, as it is * faster to iterate using our linked list." />
      <item value="Rehash the table if the threshold is exceeded" />
      <item value="overflow-conscious code" />
      <item value="old Capacity" />
      <item value="hashSeed will be zero if alternative hashing is disabled." />
      <item value="0 x 7 FFFFFFF" />
      <item value="Constructs a new, empty hashtable with a default initial capacity (11)" />
      <item value="11" />
      <item value="an {@code int} value with a single one-bit, in the position * of the highest-order one-bit in the specified value, or zero if * the specified value is itself equal to zero." />
      <item value="highest One Bit" />
      <item value="MAXIMUM CAPACITY" />
      <item value="Callbacks to allow LinkedHashMap post-actions" />
      <item value="Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table." />
      <item value="if false, the table is in creation mode." />
      <item value="if true, don't change existing value" />
      <item value="only If Absent" />
      <item value="false" />
      <item value="all other fields defaulted" />
      <item value="The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */" />
      <item value="Returns a power of two size for the given target capacity." />
      <item value="table Size For" />
      <item value="onstructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75)." />
      <item value="DEFAULT INITIAL CAPACITY" />
      <item value="The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage." />
      <item value="The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal." />
      <item value="UNTREEIFY THRESHOLD" />
      <item value="TREEIFY THRESHOLD" />
      <item value="The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="492" />
        <entry key="ENGLISH" value="493" />
        <entry key="ARABIC" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="CATALAN" value="1" />
        <entry key="CORSICAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>