<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="is not a user-defined directive" />
      <item value="FactoryBean threw exception on object creation;" />
      <item value="Forbid consumer 192.168.99.1 access service com.ivyb2b.oms.system.service.IPendingRequestService from registry 192.168.1.188:2181" />
      <item value="Please check registry access list" />
      <item value="The issue of empty Memory View in Debug session of application running with JRE 9 was fixed: JRE-641." />
      <item value="Unlimited cryptographic policy is enabled by default: JRE-638." />
      <item value="The JDK has been updated to 1.8.0_152-release-1024-b15, with the following fixes integrated:" />
      <item value="The Change Signature dialog now uses the system-wide color sÑheme for the parameters list: IDEA-134545." />
      <item value="The Eclipse compiler bundled with IntelliJ IDEA now supports Java 9 sources: IDEA-184951." />
      <item value="The updated built-in SSH client is now compatible with the new GitHub cryptographic standards." />
      <item value="pager" />
      <item value="the name of the autowire candidate, or {@code null} if none found" />
      <item value="Determine the autowire candidate in the given set of beans." />
      <item value="candidateBeans - a Map of candidate names and candidate instances that match the required type, as returned by findAutowireCandidates descriptor - the target dependency to match against" />
      <item value="check Merged Bean Definition" />
      <item value="Instantiate all remaining (non-lazy-init) singletons." />
      <item value="Check for listener beans and register them." />
      <item value="&lt;p&gt;In case of a {@link java.util.Collection} or {@link java.util.Map} * dependency type, the container will autowire all beans matching the * declared value type. In case of a Map, the keys must be declared as * type String and will be resolved to the corresponding bean names." />
      <item value="&lt;p&gt;In the case of multiple argument methods, the 'required' parameter is * applicable for all arguments." />
      <item value="&lt;p&gt;Config methods may have an arbitrary name and any number of arguments; * each of those arguments will be autowired with a matching bean in the * Spring container. Bean property setter methods are effectively just * a special case of such a general config method. Such config methods * do not have to be public." />
      <item value="&lt;p&gt;Fields are injected right after construction of a bean, before any * config methods are invoked. Such a config field does not have to be public." />
      <item value="&lt;p&gt;Only one constructor (at max) of any given bean class may carry this * annotation, indicating the constructor to autowire when used as a Spring * bean. Such a constructor does not have to be public." />
      <item value="Marks a constructor, field, setter method or config method as to be * autowired by Spring's dependency injection facilities." />
      <item value="Marks a constructor, field, setter method or config method as to be autowired by Spring's dependency injection facilities. Only one constructor (at max) of any given bean class may carry this annotation, indicating the constructor to autowire when used as a Spring bean. Such a constructor does not have to be public. Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public. Config methods may have an arbitrary name and any number of arguments; each of those arguments will be autowired with a matching bean in the Spring container. Bean property setter methods are effectively just a special case of such a general config method. Such config methods do not have to be public. In the case of multiple argument methods, the 'required' parameter is applicable for all arguments. In case of a java.util.Collection or java.util.Map dependency type, the container will autowire all beans matching the declared value type. In case of a Map, the keys must be declared as type String and will be resolved to the corresponding bean names. Note that actual injection is performed through a BeanPostProcessor which in turn means that you cannot use @Autowired to inject references into BeanPostProcessor or BeanFactoryPostProcessor types. Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor class (which, by default, checks for the presence of this annotation)." />
      <item value="equired String parameter 'catId' is not present" />
      <item value="Unsupported Operation Exception" />
      <item value="inout Type" />
      <item value="elapsed time patterns: [h],[m] and [s]" />
      <item value="for format which start with &quot;[DBNum1]&quot; or &quot;[DBNum2]&quot; or &quot;[DBNum3]&quot; could be a Chinese date" />
      <item value="Chinese" />
      <item value="date" />
      <item value="could be a Chinese date" />
      <item value="left-justified horizontal alignment" />
      <item value="Removal" />
      <item value="Aware" />
      <item value="Couldn't determine package version information." />
      <item value="You are running with Spring Security Core null" />
      <item value="determine" />
      <item value="protocol" />
      <item value="Since" />
      <item value="Modified" />
      <item value="character" />
      <item value="Deque" />
      <item value="Array Deque" />
      <item value="Sequenti" />
      <item value="This class provides a skeletal implementation of the Collection interface, to minimize the effort required to implement this interface. To implement an unmodifiable collection, the programmer needs only to extend this class and provide implementations for the iterator and size methods. (The iterator returned by the iterator method must implement hasNext and next.) To implement a modifiable collection, the programmer must additionally override this class's add method (which otherwise throws an UnsupportedOperationException), and the iterator returned by the iterator method must additionally implement its remove method. The programmer should generally provide a void (no argument) and Collection constructor, as per the recommendation in the Collection interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation." />
      <item value="consistent" />
      <item value="transitive" />
      <item value="symmetric" />
      <item value="reflexive" />
    </histories>
  </component>
</application>