<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="dercarriage" />
      <item value="undercarriage" />
      <item value="designation" />
      <item value="carrier" />
      <item value="Set the bound key to hold the string {@code value} if the bound key is absent." />
      <item value="SETNX" />
      <item value="the prefetch count" />
      <item value="How often to publish idle container events." />
      <item value="the consumerTagStrategy to set" />
      <item value="the missingQueuesFatal to set." />
      <item value="The BackOff to recover." />
      <item value="The recovery interval." />
      <item value="the advice chain to set." />
      <item value="true to reject by default." />
      <item value="set Receive Timeout" />
      <item value="The number of consecutive timeouts to trigger stopping a consumer." />
      <item value="The number of consecutive receives to trigger a new consumer." />
      <item value="The minimum interval between consumer stops." />
      <item value="The minimum interval between new consumer starts." />
      <item value="the transaction size." />
      <item value="the maximum number of consumers." />
      <item value="the minimum number of consumers to create." />
      <item value="the message converter to use" />
      <item value="evict" />
      <item value="FactoryBean for easy configuration of a ConcurrentMapCache when used within a Spring container. Can be configured through bean properties; uses the assigned Spring bean name as the default cache name. Useful for testing or simple caching scenarios, typically in combination with org.springframework.cache.support.SimpleCacheManager or dynamically through ConcurrentMapCacheManager." />
      <item value="Simple cache manager working against a given collection of caches. Useful for testing or simple caching declarations." />
      <item value="Composite CacheManager implementation that iterates over a given collection of delegate CacheManager instances. Allows NoOpCacheManager to be automatically added to the end of the list for handling cache declarations without a backing store. Otherwise, any custom CacheManager may play that role of the last delegate as well, lazily creating cache regions for any requested name. Note: Regular CacheManagers that this composite manager delegates to need to return null from getCache(String) if they are unaware of the specified cache name, allowing for iteration to the next delegate in line. However, most CacheManager implementations fall back to lazy creation of named caches once requested; check out the specific configuration details for a 'static' mode with fixed cache names, if available." />
      <item value="A basic, no operation CacheManager implementation suitable for disabling caching, typically used for backing cache declarations without an actual backing store. Will simply accept any items into the cache not actually storing them." />
      <item value="was not registered for synchronization because synchronization is not active" />
      <item value="Unsupported Encoding Exception" />
      <item value="packet Weight" />
      <item value="measure unit" />
      <item value="concurrent Consumers" />
      <item value="max Concurrent Consumers" />
      <item value="convert Rabbit Access Exception" />
      <item value="Failed to check/redeclare auto-delete queue(s)." />
      <item value="The $MODULE_DIR$ macro is now deprecated" />
      <item value="Spring Boot 2.0: new binding rules for configuration keys" />
      <item value="又认证不了" />
      <item value="buessiness Generate Id" />
      <item value="generate Id" />
      <item value="Once this method is called, calling the size(int, int) method, or the scale(double, double) method, or the keepAspectRatio(boolean) method will result in an IllegalStateException." />
      <item value="/** * Sets the size of the thumbnail. * &lt;p&gt; * For example, to create thumbnails which should fit within a * bounding rectangle of 640 x 480, the following code can be used: * &lt;pre&gt;&lt;code&gt; Thumbnails.of(image) .size(640, 480) .toFile(thumbnail); * &lt;/code&gt;&lt;/pre&gt; * &lt;p&gt; * In the above code, the thumbnail will preserve the aspect ratio * of the original image. If the thumbnail should be forced to the * specified size, the {@link #forceSize(int, int)} method can * be used instead of this method. * &lt;p&gt; * Once this method is called, calling the {@link #scale(double)} method * will result in an {@link IllegalStateException}. * &lt;p&gt; * Calling this method multiple times will result in an * {@link IllegalStateException} to be thrown." />
      <item value="The width of the thumbnail." />
      <item value="Substitute the template entries with the generated sheet data files" />
      <item value="Simple Scalar" />
      <item value="multi" />
      <item value="override Events" />
      <item value="script Access" />
      <item value="Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation. Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost. An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation. This may reduce the amount of incremental reallocation. Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be &quot;wrapped&quot; using the Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list: List list = Collections.synchronizedList(new ArrayList(...)); The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs." />
    </histories>
  </component>
</application>