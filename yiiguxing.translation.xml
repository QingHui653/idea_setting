<application>
  <component name="AppStorage">
    <histories>
      <item value="modeldto" />
      <item value="size" />
      <item value="threshold" />
      <item value="Callbacks to allow LinkedHashMap post-actions" />
      <item value="Val" />
      <item value="after Node Insertion" />
      <item value="treeify Bin" />
      <item value="preserve order" />
      <item value="Thr" />
      <item value="Tab" />
      <item value="evict" />
      <item value="Absent" />
      <item value="only If Absent" />
      <item value="the previous value associated with key, or null if there was no mapping for key. (A null return can also indicate that the map previously associated null with key.)" />
      <item value="if false, the table is in creation mode." />
      <item value="if true, don't change existing value" />
      <item value="The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds." />
      <item value="The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal." />
      <item value="The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage." />
      <item value="THRESHOLD" />
      <item value="The bin count threshold for using a tree rather than list for a bin. Bins are converted to trees when adding an element to a bin with at least this many nodes. The value must be greater than 2 and should be at least 8 to mesh with assumptions in tree removal about conversion back to plain bins upon shrinkage." />
      <item value="TREEIFY" />
      <item value="TREEIFY THRESHOLD" />
      <item value="Reclassify nodes in each list to new table. Because we * are using power-of-two expansion, the elements from * each bin must either stay at same index, or move with a * power of two offset. We eliminate unnecessary node * creation by catching cases where old nodes can be * reused because their next fields won't change. * Statistically, at the default threshold, only about * one-sixth of them need cloning when a table * doubles. The nodes they replace will be garbage * collectable as soon as they are no longer referenced by * any reader thread that may be in the midst of * concurrently traversing table. Entry accesses use plain * array indexing because they are followed by volatile * table write." />
      <item value="Clone remaining nodes" />
      <item value="Single node on list" />
      <item value="Mask" />
      <item value="size Mask" />
      <item value="/* * Reclassify nodes in each list to new table. Because we * are using power-of-two expansion, the elements from * each bin must either stay at same index, or move with a * power of two offset. We eliminate unnecessary node * creation by catching cases where old nodes can be * reused because their next fields won't change. * Statistically, at the default threshold, only about * one-sixth of them need cloning when a table * doubles. The nodes they replace will be garbage * collectable as soon as they are no longer referenced by * any reader thread that may be in the midst of * concurrently traversing table. Entry accesses use plain * array indexing because they are followed by volatile * table write. */" />
      <item value="given node to new table" />
      <item value="also adding the * given node to new table" />
      <item value="Doubles size of table and repacks entries, also adding the * given node to new table" />
      <item value="Scans for a node containing given key while trying to acquire lock, creating and returning one if not found. Upon return, guarantees that lock is held. UNlike in most methods, calls to method equals are not screened: Since traversal speed doesn't matter, we might as well help warm up the associated code and accesses as well." />
      <item value="re-traverse if entry changed" />
      <item value="MAX SCAN RETRIES" />
      <item value="a new node if key not found, else null" />
      <item value="Scans" />
      <item value="to recheck first below" />
      <item value="negative while locating node" />
      <item value="Gets the table entry for the given segment and hash" />
      <item value="use segment 0 as prototype" />
      <item value="ensure Segment" />
      <item value="recheck" />
      <item value="nonvolatile" />
      <item value="Returns the segment for the given index, creating it and recording in segment table (via CAS) if not already present." />
      <item value="Creates a new, empty map with the specified initial capacity, load factor and concurrency level." />
      <item value="create segments and segments[0]" />
      <item value="segment Shift" />
      <item value="Shift" />
      <item value="is Black 2" />
    </histories>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
  </component>
</application>