<application>
  <component name="AppStorage">
    <histories>
      <item value="Navigable Map" />
      <item value="distinguishes this * constructor from other int, float constructor." />
      <item value="distinguishes this" />
      <item value="ignored (distinguishes this" />
      <item value="dummy" />
      <item value="Constructs a new, empty linked hash set. (This package private constructor is only used by LinkedHashSet.) The backing HashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor." />
      <item value="Dummy value to associate with an Object in the backing Map" />
      <item value="Neal Gafter" />
      <item value="Josh Bloch" />
      <item value="A collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element. As implied by its name, this interface models the mathematical set abstraction. The Set interface places additional stipulations, beyond those inherited from the Collection interface, on the contracts of all constructors and on the contracts of the add, equals and hashCode methods. Declarations for other inherited methods are also included here for convenience. (The specifications accompanying these declarations have been tailored to the Set interface, but they do not contain any additional stipulations.) The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above). Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set. A special case of this prohibition is that it is not permissible for a set to contain itself as an element. Some set implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the set may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as &quot;optional&quot; in the specification for this interface. This interface is a member of the Java Collections Framework." />
      <item value="719163" />
      <item value="Fixed date of January 1, 1970 (Gregorian)" />
      <item value="The ERA constant designating the Meiji era." />
      <item value="The ERA constant designating the era before Meiji." />
      <item value="JapaneseImperialCalendar implements a Japanese calendar system in which the imperial era-based year numbering is supported from the Meiji era. The following are the eras supported by this calendar system. ERA value Era name Since (in Gregorian) ------------------------------------------------------ 0 N/A N/A 1 Meiji 1868-01-01 midnight local time 2 Taisho 1912-07-30 midnight local time 3 Showa 1926-12-25 midnight local time 4 Heisei 1989-01-08 midnight local time ------------------------------------------------------ ERA value 0 specifies the years before Meiji and the Gregorian year values are used. Unlike GregorianCalendar, the Julian to Gregorian transition is not supported because it doesn't make any sense to the Japanese calendar systems used before Meiji. To represent the years before Gregorian year 1, 0 and negative values are used. The Japanese Imperial rescripts and government decrees don't specify how to deal with time differences for applying the era transitions. This calendar implementation assumes local time for all transitions." />
      <item value="Heisei" />
      <item value="Showa" />
      <item value="Taisho" />
      <item value="Meiji" />
      <item value="Masayoshi" />
      <item value="Okutsu" />
      <item value="Masayoshi Okutsu" />
      <item value="Imperial" />
      <item value="Japanese Imperial Calendar" />
      <item value="Meiji 1868-01-01 midnight local time" />
      <item value="Identity" />
      <item value="Dual" />
      <item value="Pivot" />
      <item value="Concurrent Modification Exception" />
      <item value="Calendar" />
      <item value="Abstract Sequential List" />
      <item value="This implementation always throws an" />
      <item value="Retrieves, but does not remove, the first element of this list, or returns null if this list is empty." />
      <item value="Returns the (non-null) Node at the specified element index." />
      <item value="Unlinks non-null node x." />
      <item value="Inserts element e before non-null Node succ." />
      <item value="A linear collection that supports element insertion and removal at both ends. The name deque is short for &quot;double ended queue&quot; and is usually pronounced &quot;deck&quot;. Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit. This interface defines methods to access the elements at both ends of the deque. Methods are provided to insert, remove, and examine the element. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Deque implementations; in most implementations, insert operations cannot fail. The twelve methods described above are summarized in the following table:" />
      <item value="Deque" />
      <item value="clear to let GC do its work" />
      <item value="min Capacity" />
      <item value="DEFAULT CAPACITY" />
      <item value="huge Capacity" />
      <item value="ELEMENTDATA" />
      <item value="EMPTY" />
      <item value="EMPTY ELEMENTDATA" />
      <item value="EOF Exception" />
      <item value="Utility methods for packing/unpacking primitive values in/out of byte arrays using big-endian byte ordering." />
      <item value="Bit Sieve" />
      <item value="Immutable arbitrary-precision integers. All operations behave as if BigIntegers were represented in two's-complement notation (like Java's primitive integer types). BigInteger provides analogues to all of Java's primitive integer operators, and all relevant methods from java.lang.Math. Additionally, BigInteger provides operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and a few other miscellaneous operations. Semantics of arithmetic operations exactly mimic those of Java's integer arithmetic operators, as defined in The Java Language Specification. For example, division by zero throws an ArithmeticException, and division of a negative by a positive yields a negative (or zero) remainder. All of the details in the Spec concerning overflow are ignored, as BigIntegers are made as large as necessary to accommodate the results of an operation. Semantics of shift operations extend those of Java's shift operators to allow for negative shift distances. A right-shift with a negative shift distance results in a left shift, and vice-versa. The unsigned right shift operator (&gt;&gt;&gt;) is omitted, as this operation makes little sense in combination with the &quot;infinite word size&quot; abstraction provided by this class. Semantics of bitwise logical operations exactly mimic those of Java's bitwise integer operators. The binary operators (and, or, xor) implicitly perform sign extension on the shorter of the two operands prior to performing the operation. Comparison operations perform signed integer comparisons, analogous to those performed by Java's relational and equality operators. Modular arithmetic operations are provided to compute residues, perform exponentiation, and compute multiplicative inverses. These methods always return a non-negative result, between 0 and (modulus - 1), inclusive. Bit operations operate on a single bit of the two's-complement representation of their operand. If necessary, the operand is sign- extended so that it contains the designated bit. None of the single-bit operations can produce a BigInteger with a different sign from the BigInteger being operated on, as they affect only a single bit, and the &quot;infinite word size&quot; abstraction provided by this class ensures that there are infinitely many &quot;virtual sign bits&quot; preceding each BigInteger. For the sake of brevity and clarity, pseudo-code is used throughout the descriptions of BigInteger methods. The pseudo-code expression (i + j) is shorthand for &quot;a BigInteger whose value is that of the BigInteger i plus that of the BigInteger j.&quot; The pseudo-code expression (i == j) is shorthand for &quot;true if and only if the BigInteger i represents the same value as the BigInteger j.&quot; Other pseudo-code expressions are interpreted similarly. All methods and constructors in this class throw NullPointerException when passed a null object reference for any input parameter." />
      <item value="Bean Context Child" />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>