<application>
  <component name="AppStorage">
    <histories>
      <item value="Sets the category of the constructed Logger. By default, it will use the type where the annotation is placed." />
      <item value="A qualifier value for the specified asynchronous operation(s). May be used to determine the target executor to be used when executing this method, matching the qualifier value (or the bean name) of a specific Executor or TaskExecutor bean definition. When specified on a class level @Async annotation, indicates that the given executor should be used for all methods within the class. Method level use of Async#value always overrides any value set at the class level." />
      <item value="A qualifier value for the specified asynchronous operation(s).&#10;May be used to determine the target executor to be used when executing this method, matching the qualifier value (or the bean name) of a specific Executor or TaskExecutor bean definition.&#10;When specified on a class level @Async annotation, indicates that the given executor should be used for all methods within the class. Method level use of Async#value always overrides any value set at the class level." />
      <item value="/** * A qualifier value for the specified asynchronous operation(s). * &lt;p&gt;May be used to determine the target executor to be used when executing this * method, matching the qualifier value (or the bean name) of a specific * {@link java.util.concurrent.Executor Executor} or * {@link org.springframework.core.task.TaskExecutor TaskExecutor} * bean definition. * &lt;p&gt;When specified on a class level {@code @Async} annotation, indicates that the * given executor should be used for all methods within the class. Method level use * of {@code Async#value} always overrides any value set at the class level. * @since 3.1.2 */" />
      <item value="More than one TaskExecutor bean found within the context, and none is named &quot; + &quot;'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly &quot; + &quot;as an alias) in order to use it for async processing" />
      <item value="More than one TaskExecutor bean found within the context, and none is named &quot; + &quot;'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly &quot; + &quot;as an alias) in order to use it for async processing:" />
      <item value="Error creating bean with name 'SkuInfoService': Bean with name 'SkuInfoService' has been injected into other beans [SpuInfoService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example." />
      <item value="Delivery" />
      <item value="Invoked after all handler methods have been detected." />
      <item value="Deprecated as of 4.3, in favor of the HandlerMethod-based MVC infrastructure" />
      <item value="Provides a method for invoking the handler method for a given request after resolving its method argument values through registered HandlerMethodArgumentResolvers. Argument resolution often requires a WebDataBinder for data binding or for type conversion. Use the setDataBinderFactory(WebDataBinderFactory) property to supply a binder factory to pass to argument resolvers." />
      <item value="Support class for invoking an annotated handler method. Operates on the introspection results of a HandlerMethodResolver for a specific handler type. Used by org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter and org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter. Deprecated as of 4.3, in favor of the HandlerMethod-based MVC infrastructure" />
      <item value="Support class for invoking an annotated handler method. Operates on the introspection * results of a {@link HandlerMethodResolver} for a specific handler type." />
      <item value="Did the handler return a view to render?" />
      <item value="Apply postHandle methods of registered interceptors." />
      <item value="Actually invoke the handler." />
      <item value="No synchronization on session demanded at all..." />
      <item value="Determine handler for the current request" />
      <item value="Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch} * for the actual dispatching." />
      <item value="Initialize the HandlerMappings used by this class. * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace, * we default to BeanNameUrlHandlerMapping." />
      <item value="Initialize the HandlerMappings used by this class." />
      <item value="Well-known name for the ViewResolver object in the bean factory for this namespace. * Only used when &quot;detectAllViewResolvers&quot; is turned off." />
      <item value="Well-known name for the ThemeResolver object in the bean factory for this namespace." />
      <item value="init Strategies" />
      <item value="Resolver" />
      <item value="Multipart" />
      <item value="init Multipart Resolver" />
      <item value="This implementation calls {@link #initStrategies}." />
      <item value="A context instance was injected at construction time -&gt; use it" />
      <item value="This method will be invoked after any bean properties have been set and * the WebApplicationContext has been loaded. The default implementation is empty; * subclasses may override this method to perform any initialization they require." />
      <item value="Set bean properties from init parameters." />
      <item value="Initialize the BeanWrapper for this HttpServletBean, possibly with custom editors. This default implementation is empty." />
      <item value="Let subclasses do whatever initialization they like." />
      <item value="target invocation exception" />
      <item value="We don't roll back on this exception." />
      <item value="AOP Alliance MethodInterceptor for declarative transaction management using the common Spring transaction infrastructure (PlatformTransactionManager). Derives from the TransactionAspectSupport class which contains the integration with Spring's underlying transaction API. TransactionInterceptor simply calls the relevant superclass methods such as invokeWithinTransaction in the correct order. TransactionInterceptors are thread-safe." />
      <item value="Serialization support" />
      <item value="Proxy factory bean for simplified declarative transaction handling. This is a convenient alternative to a standard AOP org.springframework.aop.framework.ProxyFactoryBean with a separate TransactionInterceptor definition. HISTORICAL NOTE: This class was originally designed to cover the typical case of declarative transaction demarcation: namely, wrapping a singleton target object with a transactional proxy, proxying all the interfaces that the target implements. However, in Spring versions 2.0 and beyond, the functionality provided here is superseded by the more convenient tx: XML namespace. See the declarative transaction management section of the Spring reference documentation to understand the modern options for managing transactions in Spring applications. For these reasons, users should favor of the tx: XML namespace as well as the @Transactional and @EnableTransactionManagement annotations." />
      <item value="AOP Alliance MethodInterceptor for declarative transaction management using the common Spring transaction infrastructure (PlatformTransactionManager). Derives from the TransactionAspectSupport class which contains the integration with Spring's underlying transaction API. TransactionInterceptor simply calls the relevant superclass methods such as invokeWithinTransaction in the correct order." />
      <item value="Selects which implementation of AbstractTransactionManagementConfiguration should be used based on the value of EnableTransactionManagement.mode on the importing @Configuration class." />
      <item value="Selects which implementation of {@link AbstractTransactionManagementConfiguration} * should be used based on the value of {@link EnableTransactionManagement#mode} on the * importing {@code @Configuration} class." />
      <item value="Parse the transaction attribute for the given method or class, based on a known annotation type. This essentially parses a known transaction annotation into Spring's metadata attribute class. Returns null if the method/class is not transactional." />
      <item value="the class name of the bean that is being defined via parsing the supplied Element, or null if none" />
      <item value="element â€“ the Element that is being parsed" />
      <item value="Resolve the ID for the supplied BeanDefinition. When using generation, a name is generated automatically. Otherwise, the ID is extracted from the &quot;id&quot; attribute, potentially with a fallback to a generated id." />
      <item value="Resolve the ID for the supplied {@link BeanDefinition}. * &lt;p&gt;When using {@link #shouldGenerateId generation}, a name is generated automatically. * Otherwise, the ID is extracted from the &quot;id&quot; attribute, potentially with a * {@link #shouldGenerateIdAsFallback() fallback} to a generated id." />
      <item value="the object encapsulating the current state of the parsing process" />
      <item value="AbstractSingleBeanDefinitionParser Determine the bean class corresponding to the supplied Element. Note that, for application classes, it is generally preferable to override getBeanClassName instead, in order to avoid a direct dependence on the bean implementation class. The BeanDefinitionParser and its NamespaceHandler can be used within an IDE plugin then, even if the application classes are not available on the plugin's classpath." />
      <item value="JTA TRANSACTION MANAGER CLASS NAME" />
      <item value="is Present" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="6" />
        <entry key="ENGLISH" value="6" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>