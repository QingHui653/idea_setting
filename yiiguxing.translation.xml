<application>
  <component name="AppStorage">
    <histories>
      <item value="Makes no sense to ping an inmemory disc client" />
      <item value="force Quick Ping" />
      <item value="The LoadBalancer will calculate and examine zone stats of all available zones. If the Average Active Requests for any zone has reached a configured threshold, this zone will be dropped from the active server list. In case more than one zone has reached the threshold, the zone with the most active requests per server will be dropped.&#10;Once the the worst zone is dropped, a zone will be chosen among the rest with the probability proportional to its number of instances.&#10;A server will be returned from the chosen zone with a given Rule (A Rule is a load balancing strategy, for example {@link AvailabilityFilteringRule})&#10;For each request, the steps above will be repeated. That is to say, each zone related load balancing decisions are made at real time with the up-to-date statistics aiding the choice." />
      <item value="The key metric used to measure the zone condition is Average Active Requests,&#10;which is aggregated per rest client per zone. It is the&#10;total outstanding requests in a zone divided by number of available targeted instances (excluding circuit breaker tripped instances).&#10;This metric is very effective when timeout occurs slowly on a bad zone." />
      <item value="* Load balancer that can avoid a zone as a whole when choosing server." />
      <item value="Load balancer that can avoid a zone as a whole when choosing server." />
      <item value="Zone Aware" />
      <item value="Zone Aware Load Balancer" />
      <item value="set so that clients can start using these // servers right away instead // of having to wait out the ping cycle." />
      <item value="set so that clients can start using these" />
      <item value="modification" />
      <item value="track" />
      <item value="to keep track of modification of server lists" />
      <item value="A LoadBalancer that has the capabilities to obtain the candidate list of * servers using a dynamic source. i.e. The list of servers can potentially be * changed at Runtime. It also contains facilities wherein the list of servers * can be passed through a Filter criteria to filter out servers that do not * meet the desired criteria." />
      <item value="Add a list of servers to the 'allServer' list; does not verify * uniqueness, so you could give a server a greater share by adding it more * than once USED by Test Cases only for legacy reason. DO NOT USE!!" />
      <item value="cross associate with each other" />
      <item value="i.e. Rule,Ping meet your container LB" />
      <item value="LB, these are your Ping and Rule guys ..." />
      <item value="compliant value" />
      <item value="the initial delay in milliseconds as a String value, e.g. a placeholder" />
      <item value="Number of milliseconds to delay before the first execution of a" />
      <item value="the initial delay in milliseconds" />
      <item value="initial Delay" />
      <item value="trace" />
      <item value="Log a message at the TRACE level according to the specified format * and arguments. * &lt;p/&gt; * &lt;p&gt;This form avoids superfluous object creation when the logger * is disabled for the TRACE level. &lt;/p&gt;" />
      <item value="NOTE: IFF we were doing a real ping // assuming we had a large set of servers (say 15) // the logic below will run them serially // hence taking 15 times the amount of time it takes // to ping each server // A better method would be to put this in an executor // pool // But, at the time of this writing, we dont REALLY // use a Real Ping (its mostly in memory eureka call) // hence we can afford to simplify this design and run // this // serially" />
      <item value="Default answer is DEAD." />
      <item value="LoadBalancer: PingTask executing [{}] servers configured" />
      <item value="Load Balancer" />
      <item value="Candidates" />
      <item value="num Candidates" />
      <item value="I Ping Strategy" />
      <item value="ping Strategy" />
      <item value="Executor service for executing asynchronous requests." />
      <item value="ffordance to change the URI we connect to while &quot;priming&quot; // default of &quot;/&quot; is good for most - but if its heavy operation on // the server side, then a more lightweight URI can be chosen" />
      <item value="Prime Connection End Stats" />
      <item value="Prime the connections for a given Client (For those Client that * have a LoadBalancer that knows the set of Servers it will connect to) This is * mainly done to address those deployment environments (Read EC2) which benefit * from a firewall connection/path warmup prior to actual use for live requests. * &lt;p&gt; * This class is not protocol specific. Actual priming operation is delegated to * instance of {@link IPrimeConnection}, which is instantiated using reflection * according to property {@link CommonClientConfigKey#PrimeConnectionsClassName}." />
      <item value="get All Servers" />
      <item value="get Reachable Servers" />
      <item value="Only the servers that are up and reachable." />
      <item value="A Query that matches documents containing a term." />
      <item value="A Query that matches documents matching boolean combinations of other queries." />
      <item value="Failed to decode '_id'. readString can only be called when CurrentBSONType is STRING, not when CurrentBSONType is OBJECT_ID." />
      <item value="A custom Codec or PojoCodec may need to be explicitly configured and registered to handle this type." />
      <item value="Binary Operator" />
      <item value="a merge function, used to resolve collisions between * values associated with the same key, as supplied * to {@link Map#merge(Object, Object, BiFunction)}" />
      <item value="map Merger" />
      <item value="merge Function" />
      <item value="register the rule as it contains metric for available servers count" />
      <item value="This abstraction provides a wrapped mechanism to manage those runtime * shutdown hooks." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1265" />
        <entry key="ENGLISH" value="1266" />
        <entry key="ARABIC" value="1" />
        <entry key="IRISH" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="DANISH" value="2" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="5" />
        <entry key="CATALAN" value="2" />
        <entry key="CORSICAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="4" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="2" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="1" />
        <entry key="SUNDANESE" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>