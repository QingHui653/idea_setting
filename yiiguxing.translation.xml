<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="Workspace is restored to how it was in the ‘feature/StockCustomizeList' branch" />
      <item value="Implementing this interface makes sense for example when an object * requires access to a set of collaborating beans. Note that configuration * via bean references is preferable to implementing this interface just * for bean lookup purposes." />
      <item value="Interface to be implemented by any object that wishes to be notified of the ApplicationContext that it runs in. Implementing this interface makes sense for example when an object requires access to a set of collaborating beans. Note that configuration via bean references is preferable to implementing this interface just for bean lookup purposes. This interface can also be implemented if an object needs access to file resources, i.e. wants to call getResource, wants to publish an application event, or requires access to the MessageSource. However, it is preferable to implement the more specific ResourceLoaderAware, ApplicationEventPublisherAware or MessageSourceAware interface in such a specific scenario. Note that file resource dependencies can also be exposed as bean properties of type org.springframework.core.io.Resource, populated via Strings with automatic type conversion by the bean factory. This removes the need for implementing any callback interface just for the purpose of accessing a specific file resource. org.springframework.context.support.ApplicationObjectSupport is a convenience base class for application objects, implementing this interface. For a list of all bean lifecycle methods, see the BeanFactory javadocs." />
      <item value="Apply this BeanPostProcessor to the given new bean instance after any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original. In case of a FactoryBean, this callback will be invoked for both the FactoryBean instance and the objects created by the FactoryBean (as of Spring 2.0). The post-processor can decide whether to apply to either the FactoryBean or created objects or both through corresponding bean instanceof FactoryBean checks. This callback will also be invoked after a short-circuiting triggered by a InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation method, in contrast to all other BeanPostProcessor callbacks." />
      <item value="Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean * initialization callbacks (like InitializingBean's {@code afterPropertiesSet} * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original. * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean * instance and the objects created by the FactoryBean (as of Spring 2.0). The * post-processor can decide whether to apply to either the FactoryBean or created * objects or both through corresponding {@code bean instanceof FactoryBean} checks. * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method, * in contrast to all other BeanPostProcessor callbacks." />
      <item value="Apply this BeanPostProcessor to the given new bean instance before any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original." />
      <item value="Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean * initialization callbacks (like InitializingBean's {@code afterPropertiesSet} * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original." />
      <item value="&lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their * bean definitions and apply them to any beans subsequently created. * Plain bean factories allow for programmatic registration of post-processors, * applying to all beans created through this factory." />
      <item value="Factory hook that allows for custom modification of new bean instances, * e.g. checking for marker interfaces or wrapping them with proxies." />
      <item value="Factory hook that allows for custom modification of new bean instances, e.g. checking for marker interfaces or wrapping them with proxies. ApplicationContexts can autodetect BeanPostProcessor beans in their bean definitions and apply them to any beans subsequently created. Plain bean factories allow for programmatic registration of post-processors, applying to all beans created through this factory." />
      <item value="Aware" />
      <item value="10800" />
      <item value="Unsafe" />
      <item value="compare And Swap Int" />
      <item value="setup to use Unsafe.compareAndSwapInt for updates" />
      <item value="acquire" />
      <item value="fair - true if this semaphore will guarantee first-in first-out granting of permits under contention, else false" />
      <item value="if this semaphore will guarantee * first-in first-out granting of permits under contention, * else {@code false}" />
      <item value="fair" />
      <item value="in which case releases * must occur before any acquires will be granted" />
      <item value="This value may be negative" />
      <item value="the initial number of permits available." />
      <item value="permits" />
      <item value="the initial number of permits available. * This value may be negative, in which case releases * must occur before any acquires will be granted." />
      <item value="A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire blocks if necessary until a permit is available, and then takes it. Each release adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource. For example, here is a class that uses a semaphore to control access to a pool of items:" />
      <item value="Causes the current thread to wait until it is signalled or interrupted. The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens: Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or A &quot;spurious wakeup&quot; occurs. In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one." />
      <item value="Semaphore" />
      <item value="lock Interruptibly" />
      <item value="Condition" />
      <item value="Stamped Lock" />
      <item value="Reentrant Lock" />
      <item value="Reentrant Read Write Lock" />
      <item value="public class ReentrantReadWriteLock" />
      <item value="Creates a thread pool that maintains enough threads to support * the given parallelism level, and may use multiple queues to * reduce contention. The parallelism level corresponds to the * maximum number of threads actively engaged in, or available to * engage in, task processing. The actual number of threads may * grow and shrink dynamically. A work-stealing pool makes no * guarantees about the order in which submitted tasks are * executed." />
      <item value="new Work Stealing Pool" />
      <item value="Weak" />
      <item value="Weak Hash Map" />
      <item value="inout Type" />
      <item value="need Permission" />
      <item value="is Re Solr Index" />
      <item value="DEFAULT PAGE SIZE" />
      <item value="EXPORT PAGE SIZE" />
      <item value="Simple Scalar" />
      <item value="category" />
      <item value="viy" />
      <item value="Bruce" />
      <item value="出库" />
      <item value="Mapped Statements collection" />
      <item value="company Id" />
      <item value="Return code is: 401, ReasonPhrase: Unauthorized." />
    </histories>
  </component>
</application>