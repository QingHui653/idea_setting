<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="Loads the bean definitions via an XmlBeanDefinitionReader." />
      <item value="then proceed with actually loading the bean definitions." />
      <item value="Allow a subclass to provide custom initialization of the reader," />
      <item value="&quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;." />
      <item value="Parse the elements at the root level in the document:" />
      <item value="Propagate refresh to lifecycle processor first." />
      <item value="Publish the final event." />
      <item value="/** * Template method which can be overridden to add context-specific refresh work. * Called on initialization of special beans, before instantiation of singletons. * &lt;p&gt;This implementation is empty. * @throws BeansException in case of errors * @see #refresh() */" />
      <item value="Initialize other special beans in specific context subclasses." />
      <item value="/** * Modify the application context's internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for registering special * BeanPostProcessors etc in certain ApplicationContext implementations. * @param beanFactory the bean factory used by the application context */" />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Must generate CGLIB subclass." />
      <item value="Don't override the class with CGLIB if no overrides." />
      <item value="instantiate" />
      <item value="Trigger post-initialization callback for all applicable beans..." />
      <item value="Eagerly check singleton cache for manually registered singletons." />
      <item value="Trigger initialization of all non-lazy singleton beans..." />
      <item value="Eager" />
      <item value="is Eager Init" />
      <item value="remaining" />
      <item value="Instantiate" />
      <item value="temporary" />
      <item value="Allow for caching all bean definition metadata, not expecting further changes." />
      <item value="/ Allow for caching all bean definition metadata, not expecting further changes." />
      <item value="Stop using the temporary ClassLoader for type matching." />
      <item value="Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early." />
      <item value="Instantiate all remaining (non-lazy-init) singletons." />
      <item value="to perform a thread-safe type conversion using this system." />
      <item value="A service interface for type conversion. This is the entry point into the convert system." />
      <item value="Initialize conversion service for this context." />
      <item value="Check for listener beans and register them." />
      <item value="register Listeners" />
      <item value="subclasses" />
      <item value="For subclasses: do nothing by default." />
      <item value="finish Bean Factory Initialization" />
      <item value="Default implementation of the org.springframework.beans.factory.ListableBeanFactory and BeanDefinitionRegistry interfaces: a full-fledged bean factory based on bean definition objects. Typical usage is registering all bean definitions first (possibly read from a bean definition file), before accessing beans. Bean definition lookup is therefore an inexpensive operation in a local bean definition table, operating on pre-built bean definition metadata objects. Can be used as a standalone bean factory, or as a superclass for custom bean factories. Note that readers for specific bean definition formats are typically implemented separately rather than as bean factory subclasses: see for example PropertiesBeanDefinitionReader and org.springframework.beans.factory.xml.XmlBeanDefinitionReader. For an alternative implementation of the org.springframework.beans.factory.ListableBeanFactory interface, have a look at StaticListableBeanFactory, which manages existing bean instances rather than creating new ones based on bean definitions." />
      <item value="set Serialization Id" />
      <item value="Default Listable Bean Factory" />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Validate that all properties marked as required are resolvable" />
      <item value="&gt;Replace any stub property sources with actual instances." />
      <item value="Initialize any placeholder property sources in the context environment" />
      <item value="see ConfigurablePropertyResolver#setRequiredProperties" />
      <item value="Initialize message source for this context." />
      <item value="Synchronization monitor for the &quot;refresh&quot; and &quot;destroy&quot;" />
      <item value="fix bug" />
      <item value="Prepare this context for refreshing." />
      <item value="Standalone XML application context, taking the context definition files from the class path, interpreting plain paths as class path resource names that include the package path (e.g. &quot;mypackage/myresource.txt&quot;). Useful for test harnesses as well as for application contexts embedded within JARs. The config location defaults can be overridden via getConfigLocations, Config locations can either denote concrete files like &quot;/myfiles/context.xml&quot; or Ant-style patterns like &quot;/myfiles/*-context.xml&quot; (see the org.springframework.util.AntPathMatcher javadoc for pattern details). Note: In case of multiple config locations, later bean definitions will override ones defined in earlier loaded files. This can be leveraged to deliberately override certain bean definitions via an extra XML file." />
      <item value="Instantiate the root WebApplicationContext for this loader, either the default context class or a custom context class if specified. This implementation expects custom contexts to implement the ConfigurableWebApplicationContext interface. Can be overridden in subclasses. In addition, customizeContext gets called prior to refreshing the context, allowing subclasses to perform custom modifications to the context." />
      <item value="Create a new ContextLoaderListener that will create a web application context based on the &quot;contextClass&quot; and &quot;contextConfigLocation&quot; servlet context-params. See ContextLoader superclass documentation for details on default values for each. This constructor is typically used when declaring ContextLoaderListener as a &lt;listener&gt; within web.xml, where a no-arg constructor is required. The created application context will be registered into the ServletContext under the attribute name WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE and the Spring application context will be closed when the contextDestroyed lifecycle method is invoked on this listener." />
    </histories>
  </component>
</application>