<application>
  <component name="AppStorage">
    <histories>
      <item value="the class name of the bean that is being defined via parsing the supplied Element, or null if none" />
      <item value="element â€“ the Element that is being parsed" />
      <item value="Resolve the ID for the supplied BeanDefinition. When using generation, a name is generated automatically. Otherwise, the ID is extracted from the &quot;id&quot; attribute, potentially with a fallback to a generated id." />
      <item value="Resolve the ID for the supplied {@link BeanDefinition}. * &lt;p&gt;When using {@link #shouldGenerateId generation}, a name is generated automatically. * Otherwise, the ID is extracted from the &quot;id&quot; attribute, potentially with a * {@link #shouldGenerateIdAsFallback() fallback} to a generated id." />
      <item value="the object encapsulating the current state of the parsing process" />
      <item value="AbstractSingleBeanDefinitionParser Determine the bean class corresponding to the supplied Element. Note that, for application classes, it is generally preferable to override getBeanClassName instead, in order to avoid a direct dependence on the bean implementation class. The BeanDefinitionParser and its NamespaceHandler can be used within an IDE plugin then, even if the application classes are not available on the plugin's classpath." />
      <item value="JTA TRANSACTION MANAGER CLASS NAME" />
      <item value="is Present" />
      <item value="A FactoryBean equivalent to the &lt;tx:jta-transaction-manager/&gt; XML element, autodetecting WebLogic and WebSphere servers and exposing the corresponding JtaTransactionManager subclass." />
      <item value="A {@link FactoryBean} equivalent to the &amp;lt;tx:jta-transaction-manager/&amp;gt; XML element, * autodetecting WebLogic and WebSphere servers and exposing the corresponding * {@link org.springframework.transaction.jta.JtaTransactionManager} subclass." />
      <item value="The bean name of the internally managed TransactionalEventListenerFactory." />
      <item value="The name of the AspectJ transaction management @{@code Configuration} class." />
      <item value="The class name of the AspectJ transaction management aspect." />
      <item value="The bean name of the internally managed transaction aspect (used when mode == ASPECTJ)." />
      <item value="The bean name of the internally managed transaction advisor (used when mode == PROXY)." />
      <item value="Advisor" />
      <item value="Configuration constants for internal sharing across subpackages." />
      <item value="message" />
      <item value="Invocation Callback" />
      <item value="proceed With Invocation" />
      <item value="register Transaction Aspect" />
      <item value="implementation that allows users to easily configure all the infrastructure beans required to enable annotation-driven transaction demarcation. By default, all proxies are created as JDK proxies. This may cause some problems if you are injecting objects as concrete classes rather than interfaces. To overcome this restriction you can set the 'proxy-target-class' attribute to 'true', which will result in class-based proxies being created." />
      <item value="Annotation Driven Bean Definition Parser" />
      <item value="proxy" />
      <item value="aspectj" />
      <item value="Assume annotations source." />
      <item value="// Using attributes source." />
      <item value="allowed at most once inside element &lt;advice&gt;" />
      <item value="add Property Reference" />
      <item value="rollback - for" />
      <item value="timeout" />
      <item value="propagation" />
      <item value="isolation" />
      <item value="Files syntax highlight Coloring ignored files in the Project View Gitignore templates filtering and selecting in rules generator by name and content Show ignored files by specified ignore file (right click on .gitignore file) Hide ignored files in Project View Create file in currently selected directory Generate Gitignore rules basing on GitHub's templates collection Add selected file/directory to ignore rules from popup menu Suggesting .gitignore file creation for new project Entries inspection (duplicated, covered, unused, relative, incorrect syntax, relative entries) with fix actions Comments and brackets support Navigation to entries in Project view Renaming entries from ignore file Close opened ignored files action Custom user templates with import/export features Create custom templates from existing rules Favorite templates" />
      <item value="Returns {@code true} if this queue contains the specified element. * More formally, returns {@code true} if and only if this queue contains * at least one element {@code e} such that {@code o.equals(e)}." />
      <item value="the number of elements in this queue" />
      <item value="Beware that, unlike in most collections, this method is * &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the * asynchronous nature of these queues, determining the current * number of elements requires an O(n) traversal. * Additionally, if elements are added or removed during execution * of this method, the returned result may be inaccurate. Thus, * this method is typically not very useful in concurrent * applications." />
      <item value="Returns the number of elements in this queue. If this queue * contains more than {@code Integer.MAX_VALUE} elements, returns * {@code Integer.MAX_VALUE}." />
      <item value="restart From Head" />
      <item value="hop two nodes at a time" />
      <item value="Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become &quot;live&quot;." />
      <item value="Try to CAS head to p. If successful, repoint old head to itself * as sentinel for succ(), below." />
      <item value="Have to override just to update the javadoc" />
      <item value="Creates a {@code ConcurrentLinkedQueue} that is initially empty." />
      <item value="A node from which the last node on list (that is, the unique * node with node.next == null) can be reached in O(1) time. * Invariants: * - the last node is always reachable from tail via succ() * - tail != null * Non-invariants: * - tail.item may or may not be null. * - it is permitted for tail to lag behind head, that is, for tail * to not be reachable from head! * - tail.next may or may not be self-pointing to tail." />
      <item value="A node from which the first live (non-deleted) node (if any) * can be reached in O(1) time. * Invariants: * - all live nodes are reachable from head via succ() * - head != null * - (tmp = head).next != tmp || tmp != head * Non-invariants: * - head.item may or may not be null. * - it is permitted for tail to lag behind head, that is, for tail * to not be reachable from head!" />
      <item value="tail" />
      <item value="Unsafe mechanics" />
      <item value="Constructs a new node. Uses relaxed write because item can * only be seen after publication via casNext." />
      <item value="volatile" />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>