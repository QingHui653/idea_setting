<application>
  <component name="AppStorage">
    <histories>
      <item value="mod Count" />
      <item value="bucket Index" />
      <item value="bucket" />
      <item value="Access" />
      <item value="record" />
      <item value="his method is invoked whenever the value in an entry is * overwritten by an invocation of put(k,v) for a key k that's already * in the HashMap." />
      <item value="to Size" />
      <item value="Find a power of 2 &gt;= toSize" />
      <item value="capacity" />
      <item value="threshold" />
      <item value="The next size value at which to resize" />
      <item value="Returns the segment for the given index, creating it and * recording in segment table (via CAS) if not already present." />
      <item value="ensure Segment" />
      <item value="ensure" />
      <item value="to recheck first below" />
      <item value="Single node on list" />
      <item value="RETRIES" />
      <item value="SCAN" />
      <item value="MAX SCAN RETRIES" />
      <item value="This class defines only mutative methods requiring locking. * Except as noted, the methods of this class perform the * per-segment versions of ConcurrentHashMap methods. (Other * methods are integrated directly into ConcurrentHashMap * methods.) These mutative methods use a form of controlled * spinning on contention via methods scanAndLock and * scanAndLockForPut. These intersperse tryLocks with * traversals to locate nodes. The main benefit is to absorb * cache misses (which are very common for hash tables) while * obtaining locks so that traversal is faster once * acquired. We do not actually use the found nodes since they * must be re-acquired under lock anyway to ensure sequential * consistency of updates (and in any case may be undetectably * stale), but they will normally be much faster to re-locate. * Also, scanAndLockForPut speculatively creates a fresh node * to use in put if no node is found." />
      <item value="Segments maintain a table of entry lists that are always * kept in a consistent state, so can be read (via volatile * reads of segments and tables) without locking. This * requires replicating nodes when necessary during table * resizing, so the old lists can be traversed by readers * still using old version of table." />
      <item value="separate construction" />
      <item value="opportunistically" />
      <item value="This * subclasses from ReentrantLock opportunistically, just to * simplify some locking and avoid separate construction" />
      <item value="subclasses" />
      <item value="specialized" />
      <item value="Segments" />
      <item value="Segments are specialized versions of hash tables. This * subclasses from ReentrantLock opportunistically, just to * simplify some locking and avoid separate construction." />
      <item value="Reentrant Lock" />
      <item value="create segments and segments[0]" />
      <item value="Mask" />
      <item value="segment" />
      <item value="size" />
      <item value="shift" />
      <item value="sshift" />
      <item value="power - of - two" />
      <item value="Find power-of-two sizes best matching arguments" />
      <item value="he load factor threshold, used to control resizing. * Resizing may be performed when the average number of elements per * bin exceeds this threshold." />
      <item value="the initial capacity. The implementation performs internal sizing to accommodate this many elements." />
      <item value="Creates a new, empty map with the specified initial capacity, load factor and concurrency level." />
      <item value="CONCURRENCY" />
      <item value="DEFAULT CONCURRENCY LEVEL" />
      <item value="This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor)." />
      <item value="Returns an int value with at most a single one-bit, in the position of the highest-order (&quot;leftmost&quot;) one-bit in the specified int value. Returns zero if the specified value has no one-bits in its two's complement binary representation, that is, if it is equal to zero." />
      <item value="highest One Bit" />
      <item value="round Up" />
      <item value="round Up To Power Of 2" />
      <item value="transient" />
      <item value="row" />
      <item value="cols" />
    </histories>
  </component>
</application>