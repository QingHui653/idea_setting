<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="Once this method is called, calling the size(int, int) method, or the scale(double, double) method, or the keepAspectRatio(boolean) method will result in an IllegalStateException." />
      <item value="/** * Sets the size of the thumbnail. * &lt;p&gt; * For example, to create thumbnails which should fit within a * bounding rectangle of 640 x 480, the following code can be used: * &lt;pre&gt;&lt;code&gt; Thumbnails.of(image) .size(640, 480) .toFile(thumbnail); * &lt;/code&gt;&lt;/pre&gt; * &lt;p&gt; * In the above code, the thumbnail will preserve the aspect ratio * of the original image. If the thumbnail should be forced to the * specified size, the {@link #forceSize(int, int)} method can * be used instead of this method. * &lt;p&gt; * Once this method is called, calling the {@link #scale(double)} method * will result in an {@link IllegalStateException}. * &lt;p&gt; * Calling this method multiple times will result in an * {@link IllegalStateException} to be thrown." />
      <item value="The width of the thumbnail." />
      <item value="Substitute the template entries with the generated sheet data files" />
      <item value="Simple Scalar" />
      <item value="multi" />
      <item value="override Events" />
      <item value="script Access" />
      <item value="Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation. Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost. An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation. This may reduce the amount of incremental reallocation. Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be &quot;wrapped&quot; using the Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list: List list = Collections.synchronizedList(new ArrayList(...)); The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs." />
      <item value="DEFAULT CAPACITY" />
      <item value="overwritten without archiving the previous version of the log." />
      <item value="Note, changing log4j.appender.FILE.append=false will result in logs being" />
      <item value="Note, changing log4j.appender.FILE.append=false will result in logs being # overwritten without archiving the previous version of the log." />
      <item value="DailyMaxRollingFileAppender extends FileAppender so that the underlying file is rolled over at a user chosen frequency. The rolling schedule is specified by the DatePattern. This pattern should follow the SimpleDateFormat conventions. In particular, you must escape literal text within a pair of single quotes. A formatted version of the date pattern is used as the suffix for the rolled file name. For example, if the File option is set to /foo/bar.log and the DatePattern set to '.'yyyy-MM-dd, on 2001-02-16 at midnight, the logging file /foo/bar.log will be copied to /foo/bar.log.2001-02-16 and logging for 2001-02-17 will continue in /foo/bar.log until it rolls over the next day. Is is possible to specify monthly, weekly, half-daily, daily, hourly, or minutely rollover schedules." />
      <item value="DailyMaxRollingFileAppender extends {@link FileAppender} so that the * underlying file is rolled over at a user chosen frequency." />
      <item value="Serial" />
      <item value="spu Serial" />
      <item value="get Adaptive Extension" />
      <item value="modified by lishen" />
      <item value="is Callbackservice" />
      <item value="is Stub Support Event" />
      <item value="export service." />
      <item value="export an stub service for dispaching event" />
      <item value="is Default" />
      <item value="capitalize" />
      <item value="column Prefix" />
      <item value="Prefix" />
      <item value="user" />
      <item value="delay" />
      <item value="Daemon" />
      <item value="delegate" />
      <item value="rotate" />
      <item value="Delay" />
      <item value="Absent" />
      <item value="put If Absent" />
      <item value="Direct" />
      <item value="Direct Memory" />
      <item value="因 Channel Factory 的关闭有 Direct Memory 泄露" />
      <item value="* Connect a {@link Channel} to the remote peer." />
      <item value="&lt;p&gt;The {@link #bind()} methods are useful in combination with connectionless transports such as datagram (UDP). * For regular TCP connections, please use the provided {@link #connect()} methods.&lt;/p&gt;" />
      <item value="A {@link Bootstrap} that makes it easy to bootstrap a {@link Channel} to use * for clients." />
      <item value="A Bootstrap that makes it easy to bootstrap a Channel to use for clients." />
      <item value="A Bootstrap that makes it easy to bootstrap a Channel to use for clients. The bind() methods are useful in combination with connectionless transports such as datagram (UDP). For regular TCP connections, please use the provided connect() methods." />
      <item value="false" />
      <item value="Platform" />
      <item value="available" />
      <item value="Loop" />
      <item value="Event" />
      <item value="Standard" />
      <item value="Query must be not synchronized to prevent deadlocks" />
    </histories>
  </component>
</application>