<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="/** * Initialize the given bean instance, applying factory callbacks * as well as init methods and bean post processors. * &lt;p&gt;Called from {@link #createBean} for traditionally defined beans, * and from {@link #initializeBean} for existing bean instances. * @param beanName the bean name in the factory (for debugging purposes) * @param bean the new bean instance we may need to initialize * @param mbd the bean definition that the bean was created with * (can also be {@code null}, if given an existing bean instance) * @return the initialized bean instance (potentially wrapped) * @see BeanNameAware * @see BeanClassLoaderAware * @see BeanFactoryAware * @see #applyBeanPostProcessorsBeforeInitialization * @see #invokeInitMethods * @see #applyBeanPostProcessorsAfterInitialization" />
      <item value="Bean Wrapper Impl" />
      <item value="into" />
      <item value="refactoring" />
      <item value="consider" />
      <item value="consider refactoring into BeanWrapperImpl?" />
      <item value="/** * Given a PropertyValue, return a value, resolving any references to other * beans in the factory if necessary. The value could be: * &lt;li&gt;An ordinary object or null, in which case it's left alone * &lt;li&gt;A RuntimeBeanReference, which must be resolved * &lt;li&gt;A ManagedList. This is a special collection that may contain * RuntimeBeanReferences that will need to be resolved. * &lt;li&gt;A ManagedMap. In this case the value may be a reference that * must be resolved. * If the value is a simple object, but the property takes a Collection type, * the value must be placed in a list. */" />
      <item value="Initialize the bean instance." />
      <item value="Specified" />
      <item value="Method Injection" />
      <item value="// Must generate CGLIB subclass." />
      <item value="Don't override the class with CGLIB if no overrides." />
      <item value="instantiate" />
      <item value="get Instantiation Strategy" />
      <item value="// No special handling: simply use no-arg constructor." />
      <item value="Need to determine the constructor..." />
      <item value="create Bean Instance" />
      <item value="cache new instance to be able resolve circular references" />
      <item value="Convenience method to instantiate a class using its * no arg constructor. As this method doesn't try to load * classes by name, it should avoid class-loading issues." />
      <item value="cached Introspection Results" />
      <item value="wrapped" />
      <item value="The wrapped object" />
      <item value="Subclasses may override this, to create bean * wrappers differently or perform custom preprocessing. * This implementation wraps the bean class directly. * @return a new BeanWrapper wrapper the target object" />
      <item value="Given a bean wrapper, add listeners" />
      <item value="get Bean Wrapper For New Instance" />
      <item value="All bean instantiation within this class is performed by this method. * Return a BeanWrapper object for a new instance of this bean. * First look up BeanDefinition for the given bean name. * Uses recursion to support instance &quot;inheritance&quot;." />
      <item value="not found -&gt; check parent" />
      <item value="Allow post-processors to modify the merged bean definition." />
      <item value="Instantiate the bean." />
      <item value="Instantiate all remaining (non-lazy-init) singletons." />
      <item value="/** * Apply the given property values, resolving any runtime references * to other beans in this bean factory. * Must use deep copy, so we don't permanently modify this property * @param bw BeanWrapper wrapping the target object * @param pvs new property values * @param name bean name passed for better exception information * @param newlyCreatedBeans cache with newly created beans (name, instance) * if triggered by the creation of another bean, or null else * (necessary to resolve circular references) */" />
      <item value="No special handling: simply use no-arg constructor." />
      <item value="Eagerly check singleton cache for manually registered singletons." />
      <item value="/** * Return the bean with the given name, * checking the parent bean factory if not found. * @param name name of the bean to retrieve * @param newlyCreatedBeans cache with newly created beans (name, instance) * if triggered by the creation of another bean, or null else * (necessary to resolve circular references) */" />
      <item value="Return the bean with the given name," />
      <item value="Return the bean with the given name, * checking the parent bean factory if not found." />
      <item value="Try to find the bean instance in the hierarchy." />
      <item value="/** * All bean instantiation within this class is performed by this method. * Return a BeanWrapper object for a new instance of this bean. * First look up BeanDefinition for the given bean name. * Uses recursion to support instance &quot;inheritance&quot;. */" />
      <item value="Set our property values" />
      <item value="Child Bean Definition" />
      <item value="Root Bean Definition" />
      <item value="Instance" />
      <item value="Shared" />
      <item value="SharedInstance(name, newlyCreatedBeans) : createBean(name, newlyCreatedBeans); }" />
      <item value="Invoke the setApplicationContext() callback on all objects * in the context. This involves instantiating the objects. * Only singletons will be instantiated eagerly. */" />
      <item value="/** * Convenience method to return a String array as a delimited (e.g. CSV) * String. Useful for toString() implementations * @param arr array to display. Elements may be of any type (toString() will be * called on each element). * @param delim delimiter to use (probably a ,) */" />
      <item value="Bean Definition" />
      <item value="Definition" />
      <item value="/** * Invoke the setApplicationContext() callback on all objects * in the context. This involves instantiating the objects. * Only singletons will be instantiated eagerly. */" />
      <item value="/** * Initialize the config location for the current namespace. * This can be overridden in subclasses for custom config lookup. * &lt;p&gt;Default implementation returns the namespace with the default prefix * &quot;WEB-INF/&quot; and suffix &quot;.xml&quot;, if a namespace is set. For the root context, * the &quot;configLocation&quot; servlet context parameter is used, falling back to * &quot;WEB-INF/applicationContext.xml&quot; if no parameter is found. * @return the URL or path of the configuration to use */" />
    </histories>
  </component>
</application>