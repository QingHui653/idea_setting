<application>
  <component name="AppStorage">
    <histories>
      <item value="tility class for working with Strings that have placeholder values in them. A placeholder takes the form * {@code ${name}}. Using {@code PropertyPlaceholderHelper} these placeholders can be substituted for * user-supplied values. &lt;p&gt; Values for substitution can be supplied using a {@link Properties} instance or * using a {@link PlaceholderResolver}." />
      <item value="Make the given field accessible, explicitly setting it accessible if * necessary. The {@code setAccessible(true)} method is only called * when actually necessary, to avoid unnecessary conflicts with a JVM * SecurityManager (if active)." />
      <item value="Naming prefix for CGLIB-renamed methods." />
      <item value="CGLIB RENAMED METHOD PREFIX" />
      <item value="if the resource cannot be resolved to" />
      <item value="a corresponding File object" />
      <item value="Resolve the given resource location to a {@code java.io.File}, * i.e. to a file in the file system. * &lt;p&gt;Does not check whether the file actually exists; simply returns * the File that the given location would correspond to. * @param resourceLocation the resource location to resolve: either a * &quot;classpath:&quot; pseudo URL, a &quot;file:&quot; URL, or a plain file path" />
      <item value="a file in the file system" />
      <item value="URL PROTOCOL JAR" />
      <item value="least Sig Bits" />
      <item value="most Sig Bits" />
      <item value="increment And Get" />
      <item value="A simple {@link IdGenerator} that starts at 1 and increments by 1 with each call." />
      <item value="Simple Id Generator" />
      <item value="A common Spring annotation to declare that annotated elements can be {@code null} under * some circumstance. Leverages JSR 305 meta-annotations to indicate nullability in Java * to common tools with JSR 305 support and used by Kotlin to infer nullability of Spring API. * * &lt;p&gt;Should be used at parameter, return value, and field level. Methods override should * repeat parent {@code @Nullable} annotations unless they behave differently. * * &lt;p&gt;Can be used in association with {@code @NonNullApi} or {@code @NonNullFields} to * override the default non-nullable semantic to nullable." />
      <item value="Check whether the given {@code String} is empty. * &lt;p&gt;This method accepts any Object as an argument, comparing it to * {@code null} and the empty String. As a consequence, this method * will never return {@code true} for a non-null non-String object. * &lt;p&gt;The Object signature is useful for general attribute handling code * that commonly deals with Strings but generally has to iterate over * Objects since attributes may e.g. be primitive value objects as well." />
      <item value="Resolve the given String value, for example parsing placeholders. * @param strVal the original String value (never {@code null}) * @return the resolved String value (may be {@code null} when resolved to a null * value), possibly the original String value itself (in case of no placeholders * to resolve or when ignoring unresolvable placeholders) * @throws IllegalArgumentException in case of an unresolvable String value" />
      <item value="resolve String Value" />
      <item value="Value separator for system property placeholders:" />
      <item value="Prefix for system property placeholders" />
      <item value="Prefix for system property placeholders: &quot;${" />
      <item value="parameterized types are only assignable to other parameterized types and class types" />
      <item value="a parameterized type is always assignable to its raw class type" />
      <item value="just comparing two classes" />
      <item value="all types are assignable to themselves and to class Object" />
      <item value="the value type that should be assigned to the target type" />
      <item value="the target type" />
      <item value="rhs Type" />
      <item value="lhs Type" />
      <item value="is Assignable" />
      <item value="Extension of {@link java.io.InputStream} that allows for optimized * implementations of message digesting." />
      <item value="Extension of {@link java.io.InputStream} that allows for optimized" />
      <item value="Update Message Digest Input Stream" />
      <item value="get Segment For Hash" />
      <item value="RESIZE" />
      <item value="SKIP IF EMPTY" />
      <item value="RESTRUCTURE AFTER" />
      <item value="RESTRUCTURE BEFORE" />
      <item value="Various options supported by a {@code Task}." />
      <item value="Array of segments indexed using the high order bits from the hash." />
      <item value="Weak Reference" />
      <item value="Soft Reference" />
      <item value="NOTE: The use of references means that there is no guarantee that items placed into the map will be subsequently available. The garbage collector may discard references at any time, so it may appear that an unknown thread is silently removing entries. If not explicitly specified, this implementation will use soft entry references." />
      <item value="NOTE: The use of references means that there is no guarantee that items placed into the map will be subsequently available. The garbage collector may discard references at any time, so it may appear that an unknown thread is silently removing entries.&#10;If not explicitly specified, this implementation will use soft entry references." />
      <item value="A ConcurrentHashMap that uses soft or weak references for both keys and values. This class can be used as an alternative to Collections.synchronizedMap(new WeakHashMap&lt;K, Reference&lt;V&gt;&gt;()) in order to support better performance when accessed concurrently. This implementation follows the same design constraints as ConcurrentHashMap with the exception that null values and null keys are supported." />
      <item value="A ConcurrentHashMap that uses soft or weak references for both keys and values.&#10;This class can be used as an alternative to Collections.synchronizedMap(new WeakHashMap&lt;K, Reference&lt;V&gt;&gt;()) in order to support better performance when accessed concurrently. This implementation follows the same design constraints as ConcurrentHashMap with the exception that null values and null keys are supported." />
      <item value="load Balanced" />
      <item value="Load Balanced Retry Factory" />
      <item value="factory" />
      <item value="Factory for SpringLoadBalancer instances that caches the entries created." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1133" />
        <entry key="ENGLISH" value="1134" />
        <entry key="ARABIC" value="1" />
        <entry key="IRISH" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="DANISH" value="2" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="5" />
        <entry key="CATALAN" value="2" />
        <entry key="CORSICAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="2" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="1" />
        <entry key="SUNDANESE" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>