<application>
  <component name="AppStorage">
    <histories>
      <item value="register the rule as it contains metric for available servers count" />
      <item value="This abstraction provides a wrapped mechanism to manage those runtime * shutdown hooks." />
      <item value="Apparently, adding a runtime shutdown hook will create a global reference * which can cause memory leaks if not cleaned up." />
      <item value="ShutdownEnabledTimer class handles runtime shutdown issues." />
      <item value="A basic implementation of the load balancer where an arbitrary list of * servers can be set as the server pool. A ping can be set to determine the * liveness of a server. Internally, this class maintains an &quot;all&quot; server list * and an &quot;up&quot; server list and use them depending on what the caller asks for." />
      <item value="Round Robin Rule" />
      <item value="DEFAULT RULE" />
      <item value="AbstractLoadBalancer contains features required for most loadbalancing * implementations. * * An anatomy of a typical LoadBalancer consists of 1. A List of Servers (nodes) * that are potentially bucketed based on a specific criteria. 2. A Class that * defines and implements a LoadBalacing Strategy via &lt;code&gt;IRule&lt;/code&gt; 3. A * Class that defines and implements a mechanism to determine the * suitability/availability of the nodes/servers in the List." />
      <item value="List of servers that this Loadbalancer knows about" />
      <item value="delegate to {@link #chooseServer(Object)} with parameter null." />
      <item value="Initial list of servers. * This API also serves to add additional ones at a later time * The same logical server (host:port) could essentially be added multiple times * (helpful in cases where you want to give more &quot;weightage&quot; perhaps ..)" />
      <item value="Interface that defines the operations for a software loadbalancer. A typical * loadbalancer minimally need a set of servers to loadbalance for, a method to * mark a particular server to be out of rotation and a call that will choose a * server from the existing list of server." />
      <item value="Only the servers that are up and reachable." />
      <item value="Choose a server from load balancer." />
      <item value="Implementation of BeanDefinitionRegistry interface" />
      <item value="TODO: better handling of key" />
      <item value="for backwards compatibility" />
      <item value="load Balanced Rest Template Initializer Deprecated" />
      <item value="Represents a client side load balancer" />
      <item value="期末库存: 截止到结束时间 59:59的库存,期初为期末减变化量,避免在查询一次mongo" />
      <item value="init Slot Host Map" />
      <item value="Implemented by classes which use a load balancer to choose a server to * send a request to." />
      <item value="Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient" />
      <item value="return singleton HTTPRequestUtils object" />
      <item value="Returns a copy of the object, or null if the object cannot * be serialized." />
      <item value="Deep copy of an Object. The Object must be Serializable" />
      <item value="eep copy of an Object. The Object must be Serializable" />
      <item value="Deep Copy" />
      <item value="Origin" />
      <item value="chunked" />
      <item value="transfer-encoding" />
      <item value="X-Zuul-Filter-Executions" />
      <item value="key for use in TODO: determine use" />
      <item value="Control duplicated message id would be ignore in seconds" />
      <item value="Identifies a method on an {@link Endpoint} as being a read operation." />
      <item value="Endpoint to display the zuul proxy routes" />
      <item value="ndpoint to display the zuul proxy routes" />
      <item value="Endpoint for listing Zuul filters." />
      <item value="Initializes various Zuul components including" />
      <item value="Measurement" />
      <item value="Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation." />
      <item value="Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.&#10;This is an intermediate operation." />
      <item value="Returns a stream consisting of the elements of this stream, additionally * performing the provided action on each element as elements are consumed * from the resulting stream. * * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate * operation&lt;/a&gt;. * * &lt;p&gt;For parallel stream pipelines, the action may be called at * whatever time and in whatever thread the element is made available by the * upstream operation. If the action modifies shared state, * it is responsible for providing the required synchronization." />
      <item value="Consumer" />
      <item value="Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation. For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation. If the action modifies shared state, it is responsible for providing the required synchronization." />
      <item value="Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.&#10;This is an intermediate operation.&#10;For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation. If the action modifies shared state, it is responsible for providing the required synchronization." />
      <item value="Multipart" />
      <item value="From Multipart" />
      <item value="extract" />
      <item value="A time based monitoring factory that does nothing." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1215" />
        <entry key="ENGLISH" value="1216" />
        <entry key="ARABIC" value="1" />
        <entry key="IRISH" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="DANISH" value="2" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="5" />
        <entry key="CATALAN" value="2" />
        <entry key="CORSICAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="2" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="1" />
        <entry key="SUNDANESE" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>