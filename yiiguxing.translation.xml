<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="on Release" />
      <item value="on Scrolling" />
      <item value="scroll It" />
      <item value="on Pulling" />
      <item value="partner" />
      <item value="PATTERN NAME" />
      <item value="Abstract Bean Definition Parser" />
      <item value="a tiny implementation of Promises/A+." />
      <item value="org.springframework.transaction.PlatformTransactionManager implementation for a single JDBC DataSource. This class is capable of working in any environment with any JDBC driver, as long as the setup uses a javax.sql.DataSource as its Connection factory mechanism. Binds a JDBC Connection from the specified DataSource to the current thread, potentially allowing for one thread-bound Connection per DataSource. Note: The DataSource that this transaction manager operates on needs to return independent Connections. The Connections may come from a pool (the typical case), but the DataSource must not return thread-scoped / request-scoped Connections or the like. This transaction manager will associate Connections with thread-bound transactions itself, according to the specified propagation behavior. It assumes that a separate, independent Connection can be obtained even during an ongoing transaction. Application code is required to retrieve the JDBC Connection via DataSourceUtils.getConnection(DataSource) instead of a standard J2EE-style DataSource.getConnection() call. Spring classes such as org.springframework.jdbc.core.JdbcTemplate use this strategy implicitly. If not used in combination with this transaction manager, the DataSourceUtils lookup strategy behaves exactly like the native DataSource lookup; it can thus be used in a portable fashion. Alternatively, you can allow application code to work with the standard J2EE-style lookup pattern DataSource.getConnection(), for example for legacy code that is not aware of Spring at all. In that case, define a TransactionAwareDataSourceProxy for your target DataSource, and pass that proxy DataSource to your DAOs, which will automatically participate in Spring-managed transactions when accessing it. Supports custom isolation levels, and timeouts which get applied as appropriate JDBC statement timeouts. To support the latter, application code must either use org.springframework.jdbc.core.JdbcTemplate, call DataSourceUtils.applyTransactionTimeout for each created JDBC Statement, or go through a TransactionAwareDataSourceProxy which will create timeout-aware JDBC Connections and Statements automatically. Consider defining a LazyConnectionDataSourceProxy for your target DataSource, pointing both this transaction manager and your DAOs to it. This will lead to optimized handling of &quot;empty&quot; transactions, i.e. of transactions without any JDBC statements executed. A LazyConnectionDataSourceProxy will not fetch an actual JDBC Connection from the target DataSource until a Statement gets executed, lazily applying the specified transaction settings to the target Connection. This transaction manager supports nested transactions via the JDBC 3.0 java.sql.Savepoint mechanism. The &quot;nestedTransactionAllowed&quot; flag defaults to &quot;true&quot;, since nested transactions will work without restrictions on JDBC drivers that support savepoints (such as the Oracle JDBC driver). This transaction manager can be used as a replacement for the org.springframework.transaction.jta.JtaTransactionManager in the single resource case, as it does not require a container that supports JTA, typically in combination with a locally defined JDBC DataSource (e.g. an Apache Commons DBCP connection pool). Switching between this local strategy and a JTA environment is just a matter of configuration!" />
      <item value="Property 'dataSource' is required&quot;" />
      <item value="Abstract base class that implements Spring's standard transaction workflow, serving as basis for concrete platform transaction managers like org.springframework.transaction.jta.JtaTransactionManager. This base class provides the following workflow handling: determines if there is an existing transaction; applies the appropriate propagation behavior; suspends and resumes transactions if necessary; checks the rollback-only flag on commit; applies the appropriate modification on rollback (actual rollback or setting rollback-only); triggers registered synchronization callbacks (if transaction synchronization is active). Subclasses have to implement specific template methods for specific states of a transaction, e.g.: begin, suspend, resume, commit, rollback. The most important of them are abstract and must be provided by a concrete implementation; for the rest, defaults are provided, so overriding is optional. Transaction synchronization is a generic mechanism for registering callbacks that get invoked at transaction completion time. This is mainly used internally by the data access support classes for JDBC, Hibernate, JPA, etc when running within a JTA transaction: They register resources that are opened within the transaction for closing at transaction completion time, allowing e.g. for reuse of the same Hibernate Session within the transaction. The same mechanism can also be leveraged for custom synchronization needs in an application. The state of this class is serializable, to allow for serializing the transaction strategy along with proxies that carry a transaction interceptor. It is up to subclasses if they wish to make their state to be serializable too. They should implement the java.io.Serializable marker interface in that case, and potentially a private readObject() method (according to Java serialization rules) if they need to restore any transient state." />
      <item value="Exception thrown when an operation is attempted that * relies on an existing transaction (such as setting * rollback status) and there is no existing transaction. * This represents an illegal usage of the transaction API. *" />
      <item value="We may need additional runtime (argument) check." />
      <item value="We start with an index of -1 and increment early." />
      <item value="if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) { return dm.interceptor.invoke(this); }" />
      <item value="We need to create a method invocation..." />
      <item value="Proceed to the joinpoint through the interceptor chain." />
      <item value="Get the interception chain for this method." />
      <item value="Restore old proxy." />
      <item value="Must have come from TargetSource." />
      <item value="May be null. Get as late as possible to minimize the time we &quot;own&quot; the target, // in case it comes from a pool." />
      <item value="find Defined Equals And Hash Code Methods" />
      <item value="is Optimize" />
      <item value="/** * Set whether this config should be frozen. * &lt;p&gt;When a config is frozen, no advice changes can be made. This is * useful for optimization, and useful when we don't want callers to * be able to manipulate configuration after casting to Advised. */" />
      <item value="** * Subclasses may choose to implement this: for example, * to change the interfaces exposed. * &lt;p&gt;The default implementation is empty. * @param proxyFactory ProxyFactory that is already configured with * TargetSource and interfaces and will be used to create the proxy * immediately after this method returns */" />
      <item value="/** * Subclasses may choose to implement this: for example, * to change the interfaces exposed. * &lt;p&gt;The default implementation is empty. * @param proxyFactory ProxyFactory that is already configured with * TargetSource and interfaces and will be used to create the proxy * immediately after this method returns */" />
      <item value="should Proxy Target Class" />
      <item value="Expose the given target class for the specified bean, if possible." />
      <item value="has Introductions" />
      <item value="find Advisors That Can Apply" />
      <item value="found Aspect J Advice" />
      <item value="Eligible" />
      <item value="find Eligible Advisors" />
      <item value="candidate Advisors" />
      <item value="candidate" />
      <item value="Find all candidate Advisors to use in auto-proxying." />
      <item value="get Advices And Advisors For Bean" />
      <item value="Create proxy if we have advice." />
      <item value="advisor" />
      <item value="0" />
      <item value="Unit" />
      <item value="Volume" />
      <item value="Wrap the given bean if necessary, i.e. if it is eligible for being proxied." />
      <item value="/** * {@link org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator} * subclass that exposes AspectJ's invocation context and understands AspectJ's rules * for advice precedence when multiple pieces of advice come from the same aspect. *" />
      <item value="Bean Component" />
      <item value="pop" />
      <item value="register the final advisor" />
      <item value="register the pointcut" />
      <item value="configure the advisor" />
      <item value="create instance factory definition" />
    </histories>
  </component>
</application>