<application>
  <component name="AppStorage">
    <histories>
      <item value="sequence" />
      <item value="invoke" />
      <item value="contract" />
      <item value="formatter" />
      <item value="A builder for creating Feign clients without using the {@link FeignClient} annotation. * &lt;p&gt; * This builder builds the Feign client exactly like it would be created by using the * {@link FeignClient} annotation." />
      <item value="A builder for creating Feign clients without using the {@link FeignClient} annotation. * &lt;p&gt;" />
      <item value="This builder builds the Feign client exactly like it would be created by using the * {@link FeignClient} annotation." />
      <item value="A builder for creating Feign clients without using the FeignClient annotation.&#10;This builder builds the Feign client exactly like it would be created by using the FeignClient annotation." />
      <item value="A factory that creates instances of feign classes. It creates a Spring * ApplicationContext per client name, and extracts the beans that it needs from there." />
      <item value="Allows an application to customize the Feign {@link FormattingConversionService}." />
      <item value="WARNING! Nothing in this class should be @Autowired. It causes NPEs because of some lifecycle race condition." />
      <item value="the bean factory to register with" />
      <item value="Register the given bean definition with the given bean factory." />
      <item value="verify annotated class is an interface" />
      <item value="Fallback class for the specified Feign client interface. The fallback class must * implement the interface annotated by this annotation and be a valid spring bean." />
      <item value="FIXME annotation.getAliasedString(&quot;name&quot;, FeignClient.class, null);" />
      <item value="This blows up if an aliased property is overspecified" />
      <item value="is Candidate Component" />
      <item value="Candidate" />
      <item value="This argument is required, it must not be null" />
      <item value="Helper class to create a {@link TypeFilter} that matches if all the delegates * match." />
      <item value="generic" />
      <item value="generic Bean Definition" />
      <item value="register Default Configuration" />
      <item value="Gang Li" />
      <item value="and RibbonClientsConfigurationRegistgrar" />
      <item value="patterned" />
      <item value="patterned after Spring Integration IntegrationComponentScanRegistrar" />
      <item value="add Constructor Arg Value" />
      <item value="Interface to be implemented by any object that wishes to be notified of the ResourceLoader (typically the ApplicationContext) that it runs in. This is an alternative to a full ApplicationContext dependency via the ApplicationContextAware interface.&#10;Note that Resource dependencies can also be exposed as bean properties of type Resource, populated via Strings with automatic type conversion by the bean factory. This removes the need for implementing any callback interface just for the purpose of accessing a specific file resource.&#10;You typically need a ResourceLoader when your application object has to access a variety of file resources whose names are calculated. A good strategy is to make the object use a DefaultResourceLoader but still implement ResourceLoaderAware to allow for overriding when running in an ApplicationContext. See ReloadableResourceBundleMessageSource for an example.&#10;A passed-in ResourceLoader can also be checked for the ResourcePatternResolver interface and cast accordingly, to be able to resolve resource patterns into arrays of Resource objects. This will always work when running in an ApplicationContext (the context interface extends ResourcePatternResolver). Use a PathMatchingResourcePatternResolver as default. See also the ResourcePatternUtils.getResourcePatternResolver method.&#10;As alternative to a ResourcePatternResolver dependency, consider exposing bean properties of type Resource array, populated via pattern Strings with automatic type conversion by the bean factory." />
      <item value="Interface to be implemented by any bean that wishes to be notified * of the {@link Environment} that it runs in." />
      <item value="Import Bean Definition Registrar" />
      <item value="Scans for interfaces that declare they are feign clients (via @FeignClient). Configures component scanning directives for use with @Configuration classes." />
      <item value="Auto Configure Before" />
      <item value="Order is important here, last should be the default, first should be optional" />
      <item value="Conditional On Missing Class" />
      <item value="Indicates that a component is only eligible for registration when all specified conditions match. A condition is any state that can be determined programmatically before the bean definition is due to be registered (see Condition for details). The @Conditional annotation may be used in any of the following ways: as a type-level annotation on any class directly or indirectly annotated with @Component, including @Configuration classes as a meta-annotation, for the purpose of composing custom stereotype annotations as a method-level annotation on any @Bean method If a @Configuration class is marked with @Conditional, all of the @Bean methods, @Import annotations, and @ComponentScan annotations associated with that class will be subject to the conditions. NOTE: Inheritance of @Conditional annotations is not supported; any conditions from superclasses or from overridden methods will not be considered. In order to enforce these semantics, @Conditional itself is not declared as @Inherited; furthermore, any custom composed annotation that is meta-annotated with @Conditional must not be declared as @Inherited" />
      <item value="Indicates that a component is only eligible for registration when all specified conditions match.&#10;A condition is any state that can be determined programmatically before the bean definition is due to be registered (see Condition for details).&#10;The @Conditional annotation may be used in any of the following ways:&#10;as a type-level annotation on any class directly or indirectly annotated with @Component, including @Configuration classes&#10;as a meta-annotation, for the purpose of composing custom stereotype annotations&#10;as a method-level annotation on any @Bean method&#10;If a @Configuration class is marked with @Conditional, all of the @Bean methods, @Import annotations, and @ComponentScan annotations associated with that class will be subject to the conditions.&#10;NOTE: Inheritance of @Conditional annotations is not supported; any conditions from superclasses or from overridden methods will not be considered. In order to enforce these semantics, @Conditional itself is not declared as @Inherited; furthermore, any custom composed annotation that is meta-annotated with @Conditional must not be declared as @Inherited" />
      <item value="Enable Auto Configuration" />
      <item value="Autoconfiguration to be activated if Feign is in use and needs to be use Ribbon as a load balancer." />
      <item value="Annotation for interfaces declaring that a REST client with that interface should be created (e.g. for autowiring into another component). If ribbon is available it will be used to load balance the backend requests, and the load balancer can be configured using a @RibbonClient with the same name (i.e. value) as the feign client." />
      <item value="Autoconfiguration to be activated if Feign is in use and needs to be use Ribbon as a * load balancer." />
      <item value="If the accept-encoding header is present it disable transparent compression" />
      <item value="The OK HTTP client uses &quot;transparent&quot; compression." />
      <item value="Configures the Feign response compression." />
      <item value="org.springframework.cloud.openfeign.encoding @Configuration @EnableConfigurationProperties(FeignClientEncodingProperties.class) @ConditionalOnClass(Feign.class) @ConditionalOnBean(Client.class) @ConditionalOnProperty(value = &quot;feign.compression.response.enabled&quot;, matchIfMissing = false) @ConditionalOnMissingBean(type = &quot;okhttp3.OkHttpClient&quot;) @AutoConfigureAfter(FeignAutoConfiguration.class) public class FeignAcceptGzipEncodingAutoConfiguration extends Object" />
      <item value="org.springframework.cloud.openfeign.encoding @Configuration @EnableConfigurationProperties(FeignClientEncodingProperties.class) @ConditionalOnClass(Feign.class) @ConditionalOnBean(Client.class) @ConditionalOnProperty(value = &quot;feign.compression.response.enabled&quot;, matchIfMissing = false) @ConditionalOnMissingBean(type = &quot;okhttp3.OkHttpClient&quot;) @AutoConfigureAfter(FeignAutoConfiguration.class) public class FeignAcceptGzipEncodingAutoConfiguration&#10;extends Object" />
      <item value="qiudesheng" />
      <item value="media Size" />
      <item value="font Size" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="909" />
        <entry key="ENGLISH" value="910" />
        <entry key="ARABIC" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="CATALAN" value="2" />
        <entry key="CORSICAN" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>