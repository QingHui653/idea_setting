<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="the initial number of permits available. * This value may be negative, in which case releases * must occur before any acquires will be granted." />
      <item value="permits" />
      <item value="A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire blocks if necessary until a permit is available, and then takes it. Each release adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource. For example, here is a class that uses a semaphore to control access to a pool of items:" />
      <item value="Causes the current thread to wait until it is signalled or interrupted. The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens: Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or A &quot;spurious wakeup&quot; occurs. In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one." />
      <item value="acquire" />
      <item value="Semaphore" />
      <item value="lock Interruptibly" />
      <item value="Condition" />
      <item value="Stamped Lock" />
      <item value="Reentrant Lock" />
      <item value="Reentrant Read Write Lock" />
      <item value="public class ReentrantReadWriteLock" />
      <item value="Creates a thread pool that maintains enough threads to support * the given parallelism level, and may use multiple queues to * reduce contention. The parallelism level corresponds to the * maximum number of threads actively engaged in, or available to * engage in, task processing. The actual number of threads may * grow and shrink dynamically. A work-stealing pool makes no * guarantees about the order in which submitted tasks are * executed." />
      <item value="new Work Stealing Pool" />
      <item value="Weak" />
      <item value="Weak Hash Map" />
      <item value="inout Type" />
      <item value="need Permission" />
      <item value="is Re Solr Index" />
      <item value="DEFAULT PAGE SIZE" />
      <item value="EXPORT PAGE SIZE" />
      <item value="Simple Scalar" />
      <item value="category" />
      <item value="viy" />
      <item value="Bruce" />
      <item value="出库" />
      <item value="Mapped Statements collection" />
      <item value="company Id" />
      <item value="Return code is: 401, ReasonPhrase: Unauthorized." />
      <item value="is not a user-defined directive" />
      <item value="FactoryBean threw exception on object creation;" />
      <item value="Forbid consumer 192.168.99.1 access service com.ivyb2b.oms.system.service.IPendingRequestService from registry 192.168.1.188:2181" />
      <item value="Please check registry access list" />
      <item value="The issue of empty Memory View in Debug session of application running with JRE 9 was fixed: JRE-641." />
      <item value="Unlimited cryptographic policy is enabled by default: JRE-638." />
      <item value="The JDK has been updated to 1.8.0_152-release-1024-b15, with the following fixes integrated:" />
      <item value="The Change Signature dialog now uses the system-wide color sсheme for the parameters list: IDEA-134545." />
      <item value="The Eclipse compiler bundled with IntelliJ IDEA now supports Java 9 sources: IDEA-184951." />
      <item value="The updated built-in SSH client is now compatible with the new GitHub cryptographic standards." />
      <item value="pager" />
      <item value="the name of the autowire candidate, or {@code null} if none found" />
      <item value="Determine the autowire candidate in the given set of beans." />
      <item value="candidateBeans - a Map of candidate names and candidate instances that match the required type, as returned by findAutowireCandidates descriptor - the target dependency to match against" />
      <item value="check Merged Bean Definition" />
      <item value="Instantiate all remaining (non-lazy-init) singletons." />
      <item value="Check for listener beans and register them." />
      <item value="&lt;p&gt;In case of a {@link java.util.Collection} or {@link java.util.Map} * dependency type, the container will autowire all beans matching the * declared value type. In case of a Map, the keys must be declared as * type String and will be resolved to the corresponding bean names." />
      <item value="&lt;p&gt;In the case of multiple argument methods, the 'required' parameter is * applicable for all arguments." />
      <item value="&lt;p&gt;Config methods may have an arbitrary name and any number of arguments; * each of those arguments will be autowired with a matching bean in the * Spring container. Bean property setter methods are effectively just * a special case of such a general config method. Such config methods * do not have to be public." />
      <item value="&lt;p&gt;Fields are injected right after construction of a bean, before any * config methods are invoked. Such a config field does not have to be public." />
    </histories>
  </component>
</application>