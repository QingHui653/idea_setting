<application>
  <component name="AppStorage">
    <histories>
      <item value="target invocation exception" />
      <item value="We don't roll back on this exception." />
      <item value="AOP Alliance MethodInterceptor for declarative transaction management using the common Spring transaction infrastructure (PlatformTransactionManager). Derives from the TransactionAspectSupport class which contains the integration with Spring's underlying transaction API. TransactionInterceptor simply calls the relevant superclass methods such as invokeWithinTransaction in the correct order. TransactionInterceptors are thread-safe." />
      <item value="Serialization support" />
      <item value="Proxy factory bean for simplified declarative transaction handling. This is a convenient alternative to a standard AOP org.springframework.aop.framework.ProxyFactoryBean with a separate TransactionInterceptor definition. HISTORICAL NOTE: This class was originally designed to cover the typical case of declarative transaction demarcation: namely, wrapping a singleton target object with a transactional proxy, proxying all the interfaces that the target implements. However, in Spring versions 2.0 and beyond, the functionality provided here is superseded by the more convenient tx: XML namespace. See the declarative transaction management section of the Spring reference documentation to understand the modern options for managing transactions in Spring applications. For these reasons, users should favor of the tx: XML namespace as well as the @Transactional and @EnableTransactionManagement annotations." />
      <item value="AOP Alliance MethodInterceptor for declarative transaction management using the common Spring transaction infrastructure (PlatformTransactionManager). Derives from the TransactionAspectSupport class which contains the integration with Spring's underlying transaction API. TransactionInterceptor simply calls the relevant superclass methods such as invokeWithinTransaction in the correct order." />
      <item value="Selects which implementation of AbstractTransactionManagementConfiguration should be used based on the value of EnableTransactionManagement.mode on the importing @Configuration class." />
      <item value="Selects which implementation of {@link AbstractTransactionManagementConfiguration} * should be used based on the value of {@link EnableTransactionManagement#mode} on the * importing {@code @Configuration} class." />
      <item value="Parse the transaction attribute for the given method or class, based on a known annotation type. This essentially parses a known transaction annotation into Spring's metadata attribute class. Returns null if the method/class is not transactional." />
      <item value="the class name of the bean that is being defined via parsing the supplied Element, or null if none" />
      <item value="element â€“ the Element that is being parsed" />
      <item value="Resolve the ID for the supplied BeanDefinition. When using generation, a name is generated automatically. Otherwise, the ID is extracted from the &quot;id&quot; attribute, potentially with a fallback to a generated id." />
      <item value="Resolve the ID for the supplied {@link BeanDefinition}. * &lt;p&gt;When using {@link #shouldGenerateId generation}, a name is generated automatically. * Otherwise, the ID is extracted from the &quot;id&quot; attribute, potentially with a * {@link #shouldGenerateIdAsFallback() fallback} to a generated id." />
      <item value="the object encapsulating the current state of the parsing process" />
      <item value="AbstractSingleBeanDefinitionParser Determine the bean class corresponding to the supplied Element. Note that, for application classes, it is generally preferable to override getBeanClassName instead, in order to avoid a direct dependence on the bean implementation class. The BeanDefinitionParser and its NamespaceHandler can be used within an IDE plugin then, even if the application classes are not available on the plugin's classpath." />
      <item value="JTA TRANSACTION MANAGER CLASS NAME" />
      <item value="is Present" />
      <item value="A FactoryBean equivalent to the &lt;tx:jta-transaction-manager/&gt; XML element, autodetecting WebLogic and WebSphere servers and exposing the corresponding JtaTransactionManager subclass." />
      <item value="A {@link FactoryBean} equivalent to the &amp;lt;tx:jta-transaction-manager/&amp;gt; XML element, * autodetecting WebLogic and WebSphere servers and exposing the corresponding * {@link org.springframework.transaction.jta.JtaTransactionManager} subclass." />
      <item value="The bean name of the internally managed TransactionalEventListenerFactory." />
      <item value="The name of the AspectJ transaction management @{@code Configuration} class." />
      <item value="The class name of the AspectJ transaction management aspect." />
      <item value="The bean name of the internally managed transaction aspect (used when mode == ASPECTJ)." />
      <item value="The bean name of the internally managed transaction advisor (used when mode == PROXY)." />
      <item value="Advisor" />
      <item value="Configuration constants for internal sharing across subpackages." />
      <item value="message" />
      <item value="Invocation Callback" />
      <item value="proceed With Invocation" />
      <item value="register Transaction Aspect" />
      <item value="implementation that allows users to easily configure all the infrastructure beans required to enable annotation-driven transaction demarcation. By default, all proxies are created as JDK proxies. This may cause some problems if you are injecting objects as concrete classes rather than interfaces. To overcome this restriction you can set the 'proxy-target-class' attribute to 'true', which will result in class-based proxies being created." />
      <item value="Annotation Driven Bean Definition Parser" />
      <item value="proxy" />
      <item value="aspectj" />
      <item value="Assume annotations source." />
      <item value="// Using attributes source." />
      <item value="allowed at most once inside element &lt;advice&gt;" />
      <item value="add Property Reference" />
      <item value="rollback - for" />
      <item value="timeout" />
      <item value="propagation" />
      <item value="isolation" />
      <item value="Files syntax highlight Coloring ignored files in the Project View Gitignore templates filtering and selecting in rules generator by name and content Show ignored files by specified ignore file (right click on .gitignore file) Hide ignored files in Project View Create file in currently selected directory Generate Gitignore rules basing on GitHub's templates collection Add selected file/directory to ignore rules from popup menu Suggesting .gitignore file creation for new project Entries inspection (duplicated, covered, unused, relative, incorrect syntax, relative entries) with fix actions Comments and brackets support Navigation to entries in Project view Renaming entries from ignore file Close opened ignored files action Custom user templates with import/export features Create custom templates from existing rules Favorite templates" />
      <item value="Returns {@code true} if this queue contains the specified element. * More formally, returns {@code true} if and only if this queue contains * at least one element {@code e} such that {@code o.equals(e)}." />
      <item value="the number of elements in this queue" />
      <item value="Beware that, unlike in most collections, this method is * &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the * asynchronous nature of these queues, determining the current * number of elements requires an O(n) traversal. * Additionally, if elements are added or removed during execution * of this method, the returned result may be inaccurate. Thus, * this method is typically not very useful in concurrent * applications." />
      <item value="Returns the number of elements in this queue. If this queue * contains more than {@code Integer.MAX_VALUE} elements, returns * {@code Integer.MAX_VALUE}." />
      <item value="restart From Head" />
      <item value="hop two nodes at a time" />
      <item value="Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become &quot;live&quot;." />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>