<application>
  <component name="AppStorage">
    <histories>
      <item value="A common Spring annotation to declare that annotated elements can be {@code null} under * some circumstance. Leverages JSR 305 meta-annotations to indicate nullability in Java * to common tools with JSR 305 support and used by Kotlin to infer nullability of Spring API. * * &lt;p&gt;Should be used at parameter, return value, and field level. Methods override should * repeat parent {@code @Nullable} annotations unless they behave differently. * * &lt;p&gt;Can be used in association with {@code @NonNullApi} or {@code @NonNullFields} to * override the default non-nullable semantic to nullable." />
      <item value="Check whether the given {@code String} is empty. * &lt;p&gt;This method accepts any Object as an argument, comparing it to * {@code null} and the empty String. As a consequence, this method * will never return {@code true} for a non-null non-String object. * &lt;p&gt;The Object signature is useful for general attribute handling code * that commonly deals with Strings but generally has to iterate over * Objects since attributes may e.g. be primitive value objects as well." />
      <item value="Resolve the given String value, for example parsing placeholders. * @param strVal the original String value (never {@code null}) * @return the resolved String value (may be {@code null} when resolved to a null * value), possibly the original String value itself (in case of no placeholders * to resolve or when ignoring unresolvable placeholders) * @throws IllegalArgumentException in case of an unresolvable String value" />
      <item value="resolve String Value" />
      <item value="Value separator for system property placeholders:" />
      <item value="Prefix for system property placeholders" />
      <item value="Prefix for system property placeholders: &quot;${" />
      <item value="parameterized types are only assignable to other parameterized types and class types" />
      <item value="a parameterized type is always assignable to its raw class type" />
      <item value="just comparing two classes" />
      <item value="all types are assignable to themselves and to class Object" />
      <item value="the value type that should be assigned to the target type" />
      <item value="the target type" />
      <item value="rhs Type" />
      <item value="lhs Type" />
      <item value="is Assignable" />
      <item value="Extension of {@link java.io.InputStream} that allows for optimized * implementations of message digesting." />
      <item value="Extension of {@link java.io.InputStream} that allows for optimized" />
      <item value="Update Message Digest Input Stream" />
      <item value="get Segment For Hash" />
      <item value="RESIZE" />
      <item value="SKIP IF EMPTY" />
      <item value="RESTRUCTURE AFTER" />
      <item value="RESTRUCTURE BEFORE" />
      <item value="Various options supported by a {@code Task}." />
      <item value="Array of segments indexed using the high order bits from the hash." />
      <item value="Weak Reference" />
      <item value="Soft Reference" />
      <item value="NOTE: The use of references means that there is no guarantee that items placed into the map will be subsequently available. The garbage collector may discard references at any time, so it may appear that an unknown thread is silently removing entries. If not explicitly specified, this implementation will use soft entry references." />
      <item value="NOTE: The use of references means that there is no guarantee that items placed into the map will be subsequently available. The garbage collector may discard references at any time, so it may appear that an unknown thread is silently removing entries.&#10;If not explicitly specified, this implementation will use soft entry references." />
      <item value="A ConcurrentHashMap that uses soft or weak references for both keys and values. This class can be used as an alternative to Collections.synchronizedMap(new WeakHashMap&lt;K, Reference&lt;V&gt;&gt;()) in order to support better performance when accessed concurrently. This implementation follows the same design constraints as ConcurrentHashMap with the exception that null values and null keys are supported." />
      <item value="A ConcurrentHashMap that uses soft or weak references for both keys and values.&#10;This class can be used as an alternative to Collections.synchronizedMap(new WeakHashMap&lt;K, Reference&lt;V&gt;&gt;()) in order to support better performance when accessed concurrently. This implementation follows the same design constraints as ConcurrentHashMap with the exception that null values and null keys are supported." />
      <item value="load Balanced" />
      <item value="Load Balanced Retry Factory" />
      <item value="factory" />
      <item value="Factory for SpringLoadBalancer instances that caches the entries created." />
      <item value="Buffer pool(s) dump completed at 190609 10:36:53" />
      <item value="A QueryMapEncoder encodes Objects into maps of query parameter names to values." />
      <item value="Reflective" />
      <item value="Reflective Feign" />
      <item value="Synchronous Method Handler" />
      <item value="Could not read from remote repository." />
      <item value="Load Balancer Auto Configuration" />
      <item value="Load Balancer Retry Properties" />
      <item value="Retry Template" />
      <item value="Assert that the target bean class is an instance of the class where the given * method is declared. In some cases the actual controller instance at request- * processing time may be a JDK dynamic proxy (lazy initialization, prototype * beans, and others). {@code @Controller}'s that require proxying should prefer * class-based proxy mechanisms." />
      <item value="The mapped handler method class" />
      <item value="No instances available for localhost" />
      <item value="DiscoveryClient_810-CLIENT/localhost:810-client:9003 - registration status: 204" />
      <item value="registering" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1119" />
        <entry key="ENGLISH" value="1120" />
        <entry key="ARABIC" value="1" />
        <entry key="IRISH" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="DANISH" value="2" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="5" />
        <entry key="CATALAN" value="2" />
        <entry key="CORSICAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="2" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="1" />
        <entry key="SUNDANESE" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>