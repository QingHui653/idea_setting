<application>
  <component name="AppStorage">
    <histories>
      <item value="Makes available the permit for the given thread, if it * was not already available. If the thread was blocked on * {@code park} then it will unblock. Otherwise, its next call * to {@code park} is guaranteed not to block. This operation * is not guaranteed to have any effect at all if the given * thread has not been started." />
      <item value="Even though volatile, hotspot doesn't need a write barrier here." />
      <item value="&lt;p&gt;This class associates, with each thread that uses it, a permit * (in the sense of the {@link java.util.concurrent.Semaphore * Semaphore} class). A call to {@code park} will return immediately * if the permit is available, consuming it in the process; otherwise * it &lt;em&gt;may&lt;/em&gt; block. A call to {@code unpark} makes the permit * available, if it was not already available. (Unlike with Semaphores * though, permits do not accumulate. There is at most one.)" />
      <item value="Basic thread blocking primitives for creating locks and other * synchronization classes." />
      <item value="gnore interrupts while waiting" />
      <item value="&lt;dt&gt;&lt;b&gt;&lt;i&gt;Fair mode&lt;/i&gt;&lt;/b&gt; * &lt;dd&gt;When constructed as fair, threads contend for entry using an * approximately arrival-order policy. When the currently held lock * is released, either the longest-waiting single writer thread will * be assigned the write lock, or if there is a group of reader threads * waiting longer than all waiting writer threads, that group will be * assigned the read lock." />
      <item value="&lt;dt&gt;&lt;b&gt;&lt;i&gt;Non-fair mode (default)&lt;/i&gt;&lt;/b&gt; * &lt;dd&gt;When constructed as non-fair (the default), the order of entry * to the read and write lock is unspecified, subject to reentrancy * constraints. A nonfair lock that is continuously contended may * indefinitely postpone one or more reader or writer threads, but * will normally have higher throughput than a fair lock." />
      <item value="&lt;p&gt;This class does not impose a reader or writer preference * ordering for lock access. However, it does support an optional * &lt;em&gt;fairness&lt;/em&gt; policy." />
      <item value="An implementation of {@link ReadWriteLock} supporting similar * semantics to {@link ReentrantLock}. * &lt;p&gt;This class has the following properties:" />
      <item value="Synchronization implementation for ReentrantReadWriteLock. * Subclassed into fair and nonfair versions." />
      <item value="nonfair" />
      <item value="Returns the lock used for writing." />
      <item value="Returns the lock used for reading." />
      <item value="&lt;p&gt;Before waiting on the condition the lock must be held by the * current thread. * A call to {@link Condition#await()} will atomically release the lock * before waiting and re-acquire the lock before the wait returns." />
      <item value="Returns a new {@link Condition} instance that is bound to this * {@code Lock} instance." />
      <item value="interrupted" />
      <item value="Acquires the lock unless the current thread is * {@linkplain Thread#interrupt interrupted}." />
      <item value="Acquires the lock unless the current thread is" />
      <item value="&lt;p&gt;A {@code Lock} implementation may be able to detect erroneous use * of the lock, such as an invocation that would cause deadlock, and * may throw an (unchecked) exception in such circumstances. The * circumstances and the exception type must be documented by that * {@code Lock} implementation." />
      <item value="A {@code Lock} implementation may be able to detect erroneous use * of the lock, such as an invocation that would cause deadlock, and * may throw an (unchecked) exception in such circumstances. The * circumstances and the exception type must be documented by that * {@code Lock} implementation." />
      <item value="erroneous" />
      <item value="detect" />
      <item value="Implementation Considerations" />
      <item value="&lt;p&gt;If the lock is not available then the current thread becomes * disabled for thread scheduling purposes and lies dormant until the * lock has been acquired." />
      <item value="&lt;p&gt;As interruption generally implies cancellation, and checks for * interruption are often infrequent, an implementation can favor responding * to an interrupt over normal method return. This is true even if it can be * shown that the interrupt occurred after another action may have unblocked * the thread. An implementation should document this behavior." />
      <item value="&lt;p&gt;The three forms of lock acquisition (interruptible, * non-interruptible, and timed) may differ in their performance * characteristics, ordering guarantees, or other implementation * qualities. Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt; * acquisition of a lock may not be available in a given {@code Lock} * class. Consequently, an implementation is not required to define * exactly the same guarantees or semantics for all three forms of * lock acquisition, nor is it required to support interruption of an * ongoing lock acquisition. An implementation is required to clearly * document the semantics and guarantees provided by each of the * locking methods. It must also obey the interruption semantics as * defined in this interface, to the extent that interruption of lock * acquisition is supported: which is either totally, or only on * method entry." />
      <item value="Unsuccessful locking and unlocking operations, and reentrant * locking/unlocking operations, do not require any memory * synchronization effects." />
      <item value="&lt;p&gt;All {@code Lock} implementations &lt;em&gt;must&lt;/em&gt; enforce the same * memory synchronization semantics as provided by the built-in monitor * lock, as described in * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt; * The Java Language Specification (17.4 Memory Model)&lt;/a&gt;: * &lt;ul&gt; * &lt;li&gt;A successful {@code lock} operation has the same memory * synchronization effects as a successful &lt;em&gt;Lock&lt;/em&gt; action. * &lt;li&gt;A successful {@code unlock} operation has the same * memory synchronization effects as a successful &lt;em&gt;Unlock&lt;/em&gt; action. * &lt;/ul&gt;" />
      <item value="&lt;h3&gt;Memory Synchronization&lt;/h3&gt;" />
      <item value="&lt;p&gt;Except where noted, passing a {@code null} value for any * parameter will result in a {@link NullPointerException} being * thrown." />
      <item value="&lt;p&gt;Note that {@code Lock} instances are just normal objects and can * themselves be used as the target in a {@code synchronized} statement. * Acquiring the * monitor lock of a {@code Lock} instance has no specified relationship * with invoking any of the {@link #lock} methods of that instance. * It is recommended that to avoid confusion you never use {@code Lock} * instances in this way, except within their own implementation." />
      <item value="&lt;p&gt;A {@code Lock} class can also provide behavior and semantics * that is quite different from that of the implicit monitor lock, * such as guaranteed ordering, non-reentrant usage, or deadlock * detection. If an implementation provides such specialized semantics * then the implementation must document those semantics." />
      <item value="implicit monitor lock" />
      <item value="provide" />
      <item value="semantics" />
      <item value="behavior" />
      <item value="&lt;p&gt;{@code Lock} implementations provide additional functionality * over the use of {@code synchronized} methods and statements by * providing a non-blocking attempt to acquire a lock ({@link * #tryLock()}), an attempt to acquire the lock that can be * interrupted ({@link #lockInterruptibly}, and an attempt to acquire * the lock that can timeout ({@link #tryLock(long, TimeUnit)})." />
      <item value="acquire" />
      <item value="synchronized" />
      <item value="functionality" />
      <item value="additional" />
      <item value="When locking and unlocking occur in different scopes, care must be * taken to ensure that all code that is executed while the lock is * held is protected by try-finally or try-catch to ensure that the * lock is released when necessary." />
      <item value="access the resource protected by this lock" />
      <item value="&lt;p&gt;With this increased flexibility comes additional * responsibility. The absence of block-structured locking removes the * automatic release of locks that occurs with {@code synchronized} * methods and statements. In most cases, the following idiom * should be used:" />
      <item value="&lt;p&gt;While the scoping mechanism for {@code synchronized} methods * and statements makes it much easier to program with monitor locks, * and helps avoid many common programming errors involving locks, * there are occasions where you need to work with locks in a more * flexible way. For example, some algorithms for traversing * concurrently accessed data structures require the use of * &amp;quot;hand-over-hand&amp;quot; or &amp;quot;chain locking&amp;quot;: you * acquire the lock of node A, then node B, then release A and acquire * C, then release B and acquire D and so on. Implementations of the * {@code Lock} interface enable the use of such techniques by * allowing a lock to be acquired and released in different scopes, * and allowing multiple locks to be acquired and released in any * order." />
      <item value="&lt;p&gt;The use of {@code synchronized} methods or statements provides * access to the implicit monitor lock associated with every object, but * forces all lock acquisition and release to occur in a block-structured way: * when multiple locks are acquired they must be released in the opposite * order, and all locks must be released in the same lexical scope in which * they were acquired." />
      <item value="&lt;p&gt;A lock is a tool for controlling access to a shared resource by * multiple threads. Commonly, a lock provides exclusive access to a * shared resource: only one thread at a time can acquire the lock and * all access to the shared resource requires that the lock be * acquired first. However, some locks may allow concurrent access to * a shared resource, such as the read lock of a {@link ReadWriteLock}." />
      <item value="@code Lock} implementations provide more extensive locking * operations than can be obtained using {@code synchronized} methods * and statements. They allow more flexible structuring, may have * quite different properties, and may support multiple associated * {@link Condition} objects." />
      <item value="Abstract Queued Synchronizer" />
      <item value="No Such Method Exception" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="365" />
        <entry key="ENGLISH" value="366" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CORSICAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>