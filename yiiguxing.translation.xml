<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="Register bean as disposable." />
      <item value="The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization. This method MUST be invoked before the class is put into service. This annotation MUST be supported on all classes that support dependency injection. The method annotated with PostConstruct MUST be invoked even if the class does not request any resources to be injected. Only one method can be annotated with this annotation. The method on which the PostConstruct annotation is applied MUST fulfill all of the following criteria: The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification. The method defined on an interceptor class MUST HAVE one of the following signatures: void &lt;METHOD&gt;(InvocationContext) Object &lt;METHOD&gt;(InvocationContext) throws Exception Note: A PostConstruct interceptor method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events. If a PostConstruct interceptor method returns a value, it is ignored by the container. The method defined on a non-interceptor class MUST HAVE the following signature: void &lt;METHOD&gt;() The method on which PostConstruct is applied MAY be public, protected, package private or private. The method MUST NOT be static except for the application client. The method MAY be final. If the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them." />
      <item value="initialize Bean" />
      <item value="is Synthetic" />
      <item value="Create a new instance of a dynamically generated subclass implementing the * required lookups." />
      <item value="Method Injection not supported in SimpleInstantiationStrategy" />
      <item value="// Don't override the class with CGLIB if no overrides." />
      <item value="resolved" />
      <item value="Cglib Subclassing Instantiation Strategy" />
      <item value="Return the instantiation strategy to use for creating bean instances." />
      <item value="get Security Manager" />
      <item value="instantiate Using Factory Method" />
      <item value="resolve" />
      <item value="// Make sure bean class is actually resolved at this point." />
      <item value="&quot;autowire constructor&quot; (with constructor arguments by type) behavior. Also applied if explicit constructor argument values are specified, matching all remaining arguments with beans from the bean factory. This corresponds to constructor injection: In this mode, a Spring bean factory is able to host components that expect constructor-based dependency resolution." />
      <item value="autowire Constructor" />
      <item value="Need to determine the constructor..." />
      <item value="Instantiate the bean." />
      <item value="Bean Post Processors" />
      <item value="Give BeanPostProcessors a chance to return a proxy instead of the target bean instance." />
      <item value="Prepare method overrides." />
      <item value="Root Bean Definition" />
      <item value="Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc." />
      <item value="// Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition." />
      <item value="Eagerly check singleton cache for manually registered singletons." />
      <item value="Check if bean definition exists in this factory." />
      <item value="// Fail if we're already creating this bean instance: // We're assumably within a circular reference." />
      <item value="assert Bean Factory Active ();" />
      <item value="nitialize LoadTimeWeaverAware beans early to allow for registering their transformers early." />
      <item value="// Initialize conversion service for this context." />
      <item value="Check for listener beans and register them." />
      <item value="Initialize other special beans in specific context subclasses." />
      <item value="Initialize event multicaster for this context." />
      <item value="Initialize message source for this context." />
      <item value="Register bean processors that intercept bean creation." />
      <item value="Register" />
      <item value="Invoke factory processors registered as beans in the context." />
      <item value="// Allows post-processing of the bean factory in context subclasses." />
      <item value="post Process" />
      <item value="post" />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Prepare the bean factory for use in this context." />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Prepare this context for refreshing." />
      <item value="Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown." />
      <item value="Store context in local instance variable, to guarantee that" />
      <item value="invoke" />
      <item value="Aware" />
      <item value="populate" />
      <item value="populate Bean" />
    </histories>
  </component>
</application>