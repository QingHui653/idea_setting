<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="Aware" />
      <item value="10800" />
      <item value="Unsafe" />
      <item value="compare And Swap Int" />
      <item value="setup to use Unsafe.compareAndSwapInt for updates" />
      <item value="acquire" />
      <item value="fair - true if this semaphore will guarantee first-in first-out granting of permits under contention, else false" />
      <item value="if this semaphore will guarantee * first-in first-out granting of permits under contention, * else {@code false}" />
      <item value="fair" />
      <item value="in which case releases * must occur before any acquires will be granted" />
      <item value="This value may be negative" />
      <item value="the initial number of permits available." />
      <item value="permits" />
      <item value="the initial number of permits available. * This value may be negative, in which case releases * must occur before any acquires will be granted." />
      <item value="A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire blocks if necessary until a permit is available, and then takes it. Each release adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource. For example, here is a class that uses a semaphore to control access to a pool of items:" />
      <item value="Causes the current thread to wait until it is signalled or interrupted. The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens: Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or A &quot;spurious wakeup&quot; occurs. In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one." />
      <item value="Semaphore" />
      <item value="lock Interruptibly" />
      <item value="Condition" />
      <item value="Stamped Lock" />
      <item value="Reentrant Lock" />
      <item value="Reentrant Read Write Lock" />
      <item value="public class ReentrantReadWriteLock" />
      <item value="Creates a thread pool that maintains enough threads to support * the given parallelism level, and may use multiple queues to * reduce contention. The parallelism level corresponds to the * maximum number of threads actively engaged in, or available to * engage in, task processing. The actual number of threads may * grow and shrink dynamically. A work-stealing pool makes no * guarantees about the order in which submitted tasks are * executed." />
      <item value="new Work Stealing Pool" />
      <item value="Weak" />
      <item value="Weak Hash Map" />
      <item value="inout Type" />
      <item value="need Permission" />
      <item value="is Re Solr Index" />
      <item value="DEFAULT PAGE SIZE" />
      <item value="EXPORT PAGE SIZE" />
      <item value="Simple Scalar" />
      <item value="category" />
      <item value="viy" />
      <item value="Bruce" />
      <item value="出库" />
      <item value="Mapped Statements collection" />
      <item value="company Id" />
      <item value="Return code is: 401, ReasonPhrase: Unauthorized." />
      <item value="is not a user-defined directive" />
      <item value="FactoryBean threw exception on object creation;" />
      <item value="Forbid consumer 192.168.99.1 access service com.ivyb2b.oms.system.service.IPendingRequestService from registry 192.168.1.188:2181" />
      <item value="Please check registry access list" />
      <item value="The issue of empty Memory View in Debug session of application running with JRE 9 was fixed: JRE-641." />
      <item value="Unlimited cryptographic policy is enabled by default: JRE-638." />
      <item value="The JDK has been updated to 1.8.0_152-release-1024-b15, with the following fixes integrated:" />
      <item value="The Change Signature dialog now uses the system-wide color sсheme for the parameters list: IDEA-134545." />
      <item value="The Eclipse compiler bundled with IntelliJ IDEA now supports Java 9 sources: IDEA-184951." />
      <item value="The updated built-in SSH client is now compatible with the new GitHub cryptographic standards." />
    </histories>
  </component>
</application>