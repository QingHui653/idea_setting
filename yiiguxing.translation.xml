<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="rotate" />
      <item value="highest One Bit" />
      <item value="** * Compares two {@code int} values numerically. * The value returned is identical to what would be returned by: * &lt;pre&gt; * Integer.valueOf(x).compareTo(Integer.valueOf(y)) * &lt;/pre&gt; * * @param x the first {@code int} to compare * @param y the second {@code int} to compare * @return the value {@code 0} if {@code x == y}; * a value less than {@code 0} if {@code x &lt; y}; and * a value greater than {@code 0} if {@code x &gt; y} * @since 1.7 */" />
      <item value="Handle radix specifier, if present" />
      <item value="Decodes a {@code String} into an {@code Integer}. * Accepts decimal, hexadecimal, and octal numbers given * by the following grammar:" />
      <item value="Compares this object to the specified object. The result is * {@code true} if and only if the argument is not * {@code null} and is an {@code Integer} object that * contains the same {@code int} value as this object." />
      <item value="a hash code value for this object, equal to the * primitive {@code int} value represented by this * {@code Integer} object." />
      <item value="Returns a hash code for this {@code Integer}." />
      <item value="assert" />
      <item value="Integer" />
      <item value="high value may be configured by property" />
      <item value="does not contain a parsable" />
      <item value="Parses the string argument as a signed decimal integer. The * characters in the string must all be decimal digits, except * that the first character may be an ASCII minus sign {@code '-'} * (&lt;code&gt;'&amp;#92;u002D'&lt;/code&gt;) to indicate a negative value or an * ASCII plus sign {@code '+'} (&lt;code&gt;'&amp;#92;u002B'&lt;/code&gt;) to * indicate a positive value. The resulting integer value is * returned, exactly as if the argument and the radix 10 were * given as arguments to the {@link #parseInt(java.lang.String, * int)} method." />
      <item value="Accumulating negatively avoids surprises near MAX_VALUE" />
      <item value="Possible leading" />
      <item value="digit" />
      <item value="multmin" />
      <item value="negative" />
      <item value="Parses the string argument as a signed integer in the radix specified by the second argument. The characters in the string must all be digits of the specified radix (as determined by whether Character.digit(char, int) returns a nonnegative value), except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value or an ASCII plus sign '+' ('\u002B') to indicate a positive value. The resulting integer value is returned. An exception of type NumberFormatException is thrown if any of the following situations occurs: The first argument is null or is a string of length zero. The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX. Any character of the string is not a digit of the specified radix, except that the first character may be a minus sign '-' ('\u002D') or plus sign '+' ('\u002B') provided that the string is longer than length 1. The value represented by the string is not a value of type int." />
      <item value="really" />
      <item value="(q * 100);" />
      <item value="digits" />
      <item value="Places characters representing the integer i into the * character array buf. The characters are placed into * the buffer backwards starting with the least significant * digit at the specified index (exclusive), and working * backwards from there." />
      <item value="positive" />
      <item value="Requires" />
      <item value="// I use the &quot;invariant division by multiplication&quot; trick to // accelerate Integer.toString. In particular we want to // avoid division by 10. // // The &quot;trick&quot; has roughly the same performance characteristics // as the &quot;classic&quot; Integer.toString code on a non-JIT VM. // The trick avoids .rem and .div calls but has a longer code // path and is thus dominated by dispatch overhead. In the // JIT case the dispatch overhead doesn't exist and the // &quot;trick&quot; is considerably faster than the classic code. // // TODO-FIXME: convert (x * 52429) into the equiv shift-add // sequence. // // RE: Division by Invariant Integers using Multiplication // T Gralund, P Montgomery // ACM PLDI 1994 //" />
      <item value="Digit" />
      <item value="Digit Tens" />
      <item value="Convert the integer to an unsigned number." />
      <item value="Binary" />
      <item value="Octal" />
      <item value="Returns a string representation of the integer argument as an unsigned integer in base 16. The unsigned integer value is the argument plus 232 if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading 0s. If the unsigned magnitude is zero, it is represented by a single zero character '0' ('\u0030'); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as hexadecimal digits: 0123456789abcdef These are the characters '\u0030' through '\u0039' and '\u0061' through '\u0066'. If uppercase letters are desired, the String.toUpperCase() method may be called on the result: Integer.toHexString(n).toUpperCase()" />
      <item value="Hex" />
      <item value="Returns a string representation of the integer argument as an * unsigned integer in base&amp;nbsp;16. * * &lt;p&gt;The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; * if the argument is negative; otherwise, it is equal to the * argument. This value is converted to a string of ASCII digits * in hexadecimal (base&amp;nbsp;16) with no extra leading * {@code 0}s. If the unsigned magnitude is zero, it is * represented by a single zero character {@code '0'} * (&lt;code&gt;'&amp;#92;u0030'&lt;/code&gt;); otherwise, the first character of * the representation of the unsigned magnitude will not be the * zero character. The following characters are used as * hexadecimal digits:" />
      <item value="Returns a string representation of the first argument in the radix specified by the second argument. If the radix is smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX, then the radix 10 is used instead. If the first argument is negative, the first element of the result is the ASCII minus character '-' ('\u002D'). If the first argument is not negative, no sign character appears in the result. The remaining characters of the result represent the magnitude of the first argument. If the magnitude is zero, it is represented by a single zero character '0' ('\u0030'); otherwise, the first character of the representation of the magnitude will not be the zero character. The following ASCII characters are used as digits: 0123456789abcdefghijklmnopqrstuvwxyz These are '\u0030' through '\u0039' and '\u0061' through '\u007A'. If radix is N, then the first N of these characters are used as radix-N digits in the order shown. Thus, the digits for hexadecimal (radix 16) are 0123456789abcdef. If uppercase letters are desired, the String.toUpperCase() method may be called on the result: Integer.toString(n, 16).toUpperCase()" />
      <item value="All possible chars for representing a number as a String" />
      <item value="The {@code Class} instance representing the primitive type" />
      <item value="Primitive Class" />
      <item value="If you think this is an error, contact support@zeroturnaround.com." />
      <item value="Failed to acquire a seat from License Server!" />
      <item value="Trial License expired." />
      <item value="at least 0 redeploys/restarts saving you about 0 hours." />
      <item value="Over the last 2 days JRebel prevented" />
      <item value="JRebel Agent 7.1.5 (201801171200)" />
      <item value="版本的 excel" />
      <item value="Verify that merged regions do not intersect multi-cell array formulas and * no merged regions intersect another merged region in this sheet." />
      <item value="get Column Width In Pixels" />
      <item value="Get the hidden state for a given column." />
      <item value="Adds a merged region of cells on a sheet." />
      <item value="High level HSSFRow object representing a row in the sheet" />
    </histories>
  </component>
</application>