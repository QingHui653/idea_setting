<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="register the pointcut" />
      <item value="create instance factory definition" />
      <item value="create the method factory bean" />
      <item value="advice Found Already" />
      <item value="We have to parse &quot;advice&quot; and all the advice kinds in one loop, to get the // ordering semantics right." />
      <item value="advice" />
      <item value="We have to parse &quot;advice&quot; and all the advice kinds in one loop, to get the" />
      <item value="Stack" />
      <item value="State" />
      <item value="/** * Simple {@link Stack}-based structure for tracking the logical position during * a parsing process. {@link Entry entries} are added to the stack at * each point during the parse phase in a reader-specific manner. * * &lt;p&gt;Calling {@link #toString()} will render a tree-style view of the current logical * position in the parse phase. This representation is intended for use in * error messages. * * @author Rob Harrop * @since 2.0 */" />
      <item value="use Class Proxying If Necessary" />
      <item value="/** * Configures the auto proxy creator needed to support the {@link BeanDefinition BeanDefinitions} * created by the '{@code &lt;aop:config/&gt;}' tag. Will force class proxying if the * '{@code proxy-target-class}' attribute is set to '{@code true}'. * @see AopNamespaceUtils */" />
      <item value="composite Def" />
      <item value="parser Context" />
      <item value="nested Components" />
      <item value="{@link ComponentDefinition} instances, aggregating them into a named group * of components." />
      <item value="{@link ComponentDefinition} implementation that holds one or more nested" />
      <item value="Composite Component Definition" />
      <item value="/** * Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the * '{@code config}', '{@code spring-configured}', '{@code aspectj-autoproxy}' * and '{@code scoped-proxy}' tags. */" />
      <item value="Only in 2.0 XSD: moved to context namespace as of 2.1" />
      <item value="In 2.0 XSD as well as in 2.1 XSD." />
      <item value="&lt;![CDATA[ A section (compartmentalization) of AOP-specific configuration (including aspects, pointcuts, etc)." />
      <item value="Loads the bean definitions via an XmlBeanDefinitionReader." />
      <item value="Initialize any placeholder property sources in the context environment" />
      <item value="load Bean Definitions" />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="parse Custom Element" />
      <item value="parse Default Element" />
      <item value="Parse the elements at the root level in the document: * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;. * @param root the DOM root element of the document" />
      <item value="Create a new XmlBeanDefinitionReader for the given BeanFactory." />
      <item value="Prepare this context for refreshing." />
      <item value="warning no match for this type name: com.anewb.test.spring.aop.Dao" />
      <item value="** * Constant defining a value for no default - as a replacement for * {@code null} which we cannot use in annotation attributes. * &lt;p&gt;This is an artificial arrangement of 16 unicode characters, * with its sole purpose being to never match user-declared values. * @see RequestParam#defaultValue() * @see RequestHeader#defaultValue() * @see CookieValue#defaultValue() */" />
      <item value="Register bean as disposable." />
      <item value="The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization. This method MUST be invoked before the class is put into service. This annotation MUST be supported on all classes that support dependency injection. The method annotated with PostConstruct MUST be invoked even if the class does not request any resources to be injected. Only one method can be annotated with this annotation. The method on which the PostConstruct annotation is applied MUST fulfill all of the following criteria: The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification. The method defined on an interceptor class MUST HAVE one of the following signatures: void &lt;METHOD&gt;(InvocationContext) Object &lt;METHOD&gt;(InvocationContext) throws Exception Note: A PostConstruct interceptor method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events. If a PostConstruct interceptor method returns a value, it is ignored by the container. The method defined on a non-interceptor class MUST HAVE the following signature: void &lt;METHOD&gt;() The method on which PostConstruct is applied MAY be public, protected, package private or private. The method MUST NOT be static except for the application client. The method MAY be final. If the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them." />
      <item value="initialize Bean" />
      <item value="is Synthetic" />
      <item value="Create a new instance of a dynamically generated subclass implementing the * required lookups." />
      <item value="Method Injection not supported in SimpleInstantiationStrategy" />
      <item value="// Don't override the class with CGLIB if no overrides." />
      <item value="resolved" />
      <item value="Cglib Subclassing Instantiation Strategy" />
      <item value="Return the instantiation strategy to use for creating bean instances." />
      <item value="get Security Manager" />
      <item value="instantiate Using Factory Method" />
      <item value="resolve" />
      <item value="// Make sure bean class is actually resolved at this point." />
      <item value="&quot;autowire constructor&quot; (with constructor arguments by type) behavior. Also applied if explicit constructor argument values are specified, matching all remaining arguments with beans from the bean factory. This corresponds to constructor injection: In this mode, a Spring bean factory is able to host components that expect constructor-based dependency resolution." />
      <item value="autowire Constructor" />
      <item value="Need to determine the constructor..." />
    </histories>
  </component>
</application>