<application>
  <component name="AppStorage">
    <histories>
      <item value="is Black 2" />
      <item value="body[6]=swapSellerOrderstatus2(purchaseOrdersDTO.getSellerOrderstatus()); //订单状态" />
      <item value="swap Seller Orderstatus 2" />
      <item value="body" />
      <item value="swap Delivevr 2" />
      <item value="seg" />
      <item value="mod Count" />
      <item value="null" />
      <item value="segment At" />
      <item value="/** * Creates a new, empty map with the specified initial capacity, * and with default load factor (0.75) and concurrencyLevel (16). * * @param initialCapacity the initial capacity. The implementation * performs internal sizing to accommodate this many elements. * @throws IllegalArgumentException if the initial capacity of * elements is negative. */" />
      <item value="/** * Creates a new, empty map with a default initial capacity (16), * load factor (0.75) and concurrencyLevel (16). */" />
      <item value="Creates a new, empty map with a default initial capacity (16), * load factor (0.75) and concurrencyLevel (16)." />
      <item value="Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result." />
      <item value="RETRIES BEFORE LOCK" />
      <item value="The maximum number of segments to allow; used to bound * constructor arguments. Must be power of two less than 1 &lt;&lt; 24." />
      <item value="1 &lt;&lt; 16" />
      <item value="MIN SEGMENT TABLE CAPACITY" />
      <item value="used when not * otherwise specified in a constructor." />
      <item value="The default concurrency level for this table" />
      <item value="DEFAULT CONCURRENCY LEVEL" />
      <item value="bucket Index" />
      <item value="bucket" />
      <item value="Access" />
      <item value="record" />
      <item value="his method is invoked whenever the value in an entry is * overwritten by an invocation of put(k,v) for a key k that's already * in the HashMap." />
      <item value="to Size" />
      <item value="Find a power of 2 &gt;= toSize" />
      <item value="capacity" />
      <item value="threshold" />
      <item value="The next size value at which to resize" />
      <item value="Returns the segment for the given index, creating it and * recording in segment table (via CAS) if not already present." />
      <item value="ensure Segment" />
      <item value="ensure" />
      <item value="to recheck first below" />
      <item value="Single node on list" />
      <item value="RETRIES" />
      <item value="SCAN" />
      <item value="MAX SCAN RETRIES" />
      <item value="This class defines only mutative methods requiring locking. * Except as noted, the methods of this class perform the * per-segment versions of ConcurrentHashMap methods. (Other * methods are integrated directly into ConcurrentHashMap * methods.) These mutative methods use a form of controlled * spinning on contention via methods scanAndLock and * scanAndLockForPut. These intersperse tryLocks with * traversals to locate nodes. The main benefit is to absorb * cache misses (which are very common for hash tables) while * obtaining locks so that traversal is faster once * acquired. We do not actually use the found nodes since they * must be re-acquired under lock anyway to ensure sequential * consistency of updates (and in any case may be undetectably * stale), but they will normally be much faster to re-locate. * Also, scanAndLockForPut speculatively creates a fresh node * to use in put if no node is found." />
      <item value="Segments maintain a table of entry lists that are always * kept in a consistent state, so can be read (via volatile * reads of segments and tables) without locking. This * requires replicating nodes when necessary during table * resizing, so the old lists can be traversed by readers * still using old version of table." />
      <item value="separate construction" />
      <item value="opportunistically" />
      <item value="This * subclasses from ReentrantLock opportunistically, just to * simplify some locking and avoid separate construction" />
      <item value="subclasses" />
      <item value="specialized" />
      <item value="Segments" />
      <item value="Segments are specialized versions of hash tables. This * subclasses from ReentrantLock opportunistically, just to * simplify some locking and avoid separate construction." />
      <item value="Reentrant Lock" />
      <item value="create segments and segments[0]" />
      <item value="Mask" />
    </histories>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
  </component>
</application>