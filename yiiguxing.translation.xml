<application>
  <component name="AppStorage">
    <histories>
      <item value="Apply postHandle methods of registered interceptors." />
      <item value="Actually invoke the handler." />
      <item value="No synchronization on session demanded at all..." />
      <item value="Determine handler for the current request" />
      <item value="Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch} * for the actual dispatching." />
      <item value="Initialize the HandlerMappings used by this class. * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace, * we default to BeanNameUrlHandlerMapping." />
      <item value="Initialize the HandlerMappings used by this class." />
      <item value="Well-known name for the ViewResolver object in the bean factory for this namespace. * Only used when &quot;detectAllViewResolvers&quot; is turned off." />
      <item value="Well-known name for the ThemeResolver object in the bean factory for this namespace." />
      <item value="init Strategies" />
      <item value="Resolver" />
      <item value="Multipart" />
      <item value="init Multipart Resolver" />
      <item value="This implementation calls {@link #initStrategies}." />
      <item value="A context instance was injected at construction time -&gt; use it" />
      <item value="This method will be invoked after any bean properties have been set and * the WebApplicationContext has been loaded. The default implementation is empty; * subclasses may override this method to perform any initialization they require." />
      <item value="Set bean properties from init parameters." />
      <item value="Initialize the BeanWrapper for this HttpServletBean, possibly with custom editors. This default implementation is empty." />
      <item value="Let subclasses do whatever initialization they like." />
      <item value="target invocation exception" />
      <item value="We don't roll back on this exception." />
      <item value="AOP Alliance MethodInterceptor for declarative transaction management using the common Spring transaction infrastructure (PlatformTransactionManager). Derives from the TransactionAspectSupport class which contains the integration with Spring's underlying transaction API. TransactionInterceptor simply calls the relevant superclass methods such as invokeWithinTransaction in the correct order. TransactionInterceptors are thread-safe." />
      <item value="Serialization support" />
      <item value="Proxy factory bean for simplified declarative transaction handling. This is a convenient alternative to a standard AOP org.springframework.aop.framework.ProxyFactoryBean with a separate TransactionInterceptor definition. HISTORICAL NOTE: This class was originally designed to cover the typical case of declarative transaction demarcation: namely, wrapping a singleton target object with a transactional proxy, proxying all the interfaces that the target implements. However, in Spring versions 2.0 and beyond, the functionality provided here is superseded by the more convenient tx: XML namespace. See the declarative transaction management section of the Spring reference documentation to understand the modern options for managing transactions in Spring applications. For these reasons, users should favor of the tx: XML namespace as well as the @Transactional and @EnableTransactionManagement annotations." />
      <item value="AOP Alliance MethodInterceptor for declarative transaction management using the common Spring transaction infrastructure (PlatformTransactionManager). Derives from the TransactionAspectSupport class which contains the integration with Spring's underlying transaction API. TransactionInterceptor simply calls the relevant superclass methods such as invokeWithinTransaction in the correct order." />
      <item value="Selects which implementation of AbstractTransactionManagementConfiguration should be used based on the value of EnableTransactionManagement.mode on the importing @Configuration class." />
      <item value="Selects which implementation of {@link AbstractTransactionManagementConfiguration} * should be used based on the value of {@link EnableTransactionManagement#mode} on the * importing {@code @Configuration} class." />
      <item value="Parse the transaction attribute for the given method or class, based on a known annotation type. This essentially parses a known transaction annotation into Spring's metadata attribute class. Returns null if the method/class is not transactional." />
      <item value="the class name of the bean that is being defined via parsing the supplied Element, or null if none" />
      <item value="element â€“ the Element that is being parsed" />
      <item value="Resolve the ID for the supplied BeanDefinition. When using generation, a name is generated automatically. Otherwise, the ID is extracted from the &quot;id&quot; attribute, potentially with a fallback to a generated id." />
      <item value="Resolve the ID for the supplied {@link BeanDefinition}. * &lt;p&gt;When using {@link #shouldGenerateId generation}, a name is generated automatically. * Otherwise, the ID is extracted from the &quot;id&quot; attribute, potentially with a * {@link #shouldGenerateIdAsFallback() fallback} to a generated id." />
      <item value="the object encapsulating the current state of the parsing process" />
      <item value="AbstractSingleBeanDefinitionParser Determine the bean class corresponding to the supplied Element. Note that, for application classes, it is generally preferable to override getBeanClassName instead, in order to avoid a direct dependence on the bean implementation class. The BeanDefinitionParser and its NamespaceHandler can be used within an IDE plugin then, even if the application classes are not available on the plugin's classpath." />
      <item value="JTA TRANSACTION MANAGER CLASS NAME" />
      <item value="is Present" />
      <item value="A FactoryBean equivalent to the &lt;tx:jta-transaction-manager/&gt; XML element, autodetecting WebLogic and WebSphere servers and exposing the corresponding JtaTransactionManager subclass." />
      <item value="A {@link FactoryBean} equivalent to the &amp;lt;tx:jta-transaction-manager/&amp;gt; XML element, * autodetecting WebLogic and WebSphere servers and exposing the corresponding * {@link org.springframework.transaction.jta.JtaTransactionManager} subclass." />
      <item value="The bean name of the internally managed TransactionalEventListenerFactory." />
      <item value="The name of the AspectJ transaction management @{@code Configuration} class." />
      <item value="The class name of the AspectJ transaction management aspect." />
      <item value="The bean name of the internally managed transaction aspect (used when mode == ASPECTJ)." />
      <item value="The bean name of the internally managed transaction advisor (used when mode == PROXY)." />
      <item value="Advisor" />
      <item value="Configuration constants for internal sharing across subpackages." />
      <item value="message" />
      <item value="Invocation Callback" />
      <item value="proceed With Invocation" />
      <item value="register Transaction Aspect" />
      <item value="implementation that allows users to easily configure all the infrastructure beans required to enable annotation-driven transaction demarcation. By default, all proxies are created as JDK proxies. This may cause some problems if you are injecting objects as concrete classes rather than interfaces. To overcome this restriction you can set the 'proxy-target-class' attribute to 'true', which will result in class-based proxies being created." />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>