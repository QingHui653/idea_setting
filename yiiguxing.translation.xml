<application>
  <component name="AppStorage">
    <histories>
      <item value="Graphite" />
      <item value="Metric" />
      <item value="method" />
      <item value="Annotation that marks a method as a candidate for &lt;i&gt;asynchronous&lt;/i&gt; execution. * Can also be used at the type level, in which case all of the type's methods are * considered as asynchronous." />
      <item value="Annotation that marks a method as a candidate for asynchronous execution. Can also be used at the type level, in which case all of the type's methods are considered as asynchronous. In terms of target method signatures, any parameter types are supported. However, the return type is constrained to either void or java.util.concurrent.Future. In the latter case, the Future handle returned from the proxy will be an actual asynchronous Future that can be used to track the result of the asynchronous method execution. However, since the target method needs to implement the same signature, it will have to return a temporary Future handle that just passes the return value through: e.g. Spring's AsyncResult or EJB 3.1's" />
      <item value="sku code" />
      <item value="Invalid character found in method name. HTTP method names must be tokens" />
      <item value="FROM" />
      <item value="warehouse Sku" />
      <item value="spu Name" />
      <item value="@param region to merge * @return index of this region * @throws IllegalArgumentException if region contains fewer than 2 cells * @throws IllegalStateException if region intersects with a multi-cell array formula * @throws IllegalStateException if region intersects with an existing region on this sheet" />
      <item value="Adds a merged region of cells on a sheet." />
      <item value="declares multiple JSON fields named id" />
      <item value="signfor Outbound" />
      <item value="INSPECTION FILE" />
      <item value="recharge" />
      <item value="recharge Serial Number" />
      <item value="enter Receipt Order Info" />
      <item value="enter" />
      <item value="ente" />
      <item value="Deprecated" />
      <item value="abnormal" />
      <item value="abnormal Out" />
      <item value="IAreaService is not visible from class loader" />
      <item value="Loan Code (" />
      <item value="approval" />
      <item value="association" />
      <item value="collection" />
      <item value="set Delivered Money" />
      <item value="This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor)." />
      <item value="/** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */" />
      <item value="assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;" />
      <item value="Returns index for hash code h." />
      <item value="modeldto" />
      <item value="size" />
      <item value="threshold" />
      <item value="Callbacks to allow LinkedHashMap post-actions" />
      <item value="Val" />
      <item value="after Node Insertion" />
      <item value="treeify Bin" />
      <item value="preserve order" />
      <item value="Thr" />
      <item value="Tab" />
      <item value="evict" />
      <item value="Absent" />
      <item value="only If Absent" />
      <item value="the previous value associated with key, or null if there was no mapping for key. (A null return can also indicate that the map previously associated null with key.)" />
      <item value="if false, the table is in creation mode." />
      <item value="if true, don't change existing value" />
      <item value="The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds." />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>