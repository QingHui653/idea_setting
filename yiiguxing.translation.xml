<application>
  <component name="AppStorage">
    <histories>
      <item value="Sorts the specified array into ascending numerical order." />
      <item value="a the array to be sorted" />
      <item value="parallel Sort" />
      <item value="Contents of collection 'nums' are queried, but never updated" />
      <item value="原始" />
      <item value="打乱" />
      <item value="platform" />
      <item value="security Uri" />
      <item value="methods Condition" />
      <item value="Invalid AES key length: 8 bytes" />
      <item value="Value that indicates that only properties with non-null * values are to be included." />
      <item value="Invalid property 'data[0][businessType]' of bean class [com.ivyb2b.ops.api.controller.workbench.Page]: Index of out of bounds in property path 'data[0][businessType]';" />
      <item value="Invalid property 'data' of bean class [com.ivyb2b.common.bean.Pager]: Bean property 'data' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?" />
      <item value="'scope' is defined but never used" />
      <item value="You may use special comments to disable some warnings" />
      <item value="You are using an offline license." />
      <item value="You are advised to use Spring 4.3.19.RELEASE or later with this version. You are running: 4.3.3.RELEASE" />
      <item value="receipt Warehouse Id" />
      <item value="is Positive Integer" />
      <item value="Cursor" />
      <item value="加载类路径" />
      <item value="配置" />
      <item value="spi配置文件 配置在 加载类路径下/META-INF/services/接口全称" />
      <item value="Multiple Spring Data modules found, entering strict repository configuration mode!" />
      <item value="Enabling autowire by type for MapperFactoryBean" />
      <item value="definition" />
      <item value="213" />
      <item value="0 x 1.0 p-1022" />
      <item value="/** * A constant holding the positive infinity of type * {@code double}. It is equal to the value returned by * {@code Double.longBitsToDouble(0x7ff0000000000000L)}. */" />
      <item value="set the data format (must be a valid format). Built in formats are defined at {@link BuiltinFormats}." />
      <item value="Set whether the text should be wrapped. * Setting this flag to &lt;code&gt;true&lt;/code&gt; make all content visible * within a cell by displaying it on multiple lines" />
      <item value="set the type of vertical alignment for the cell" />
      <item value="Annotation that marks a method as a candidate for asynchronous execution. Can also be used at the type level, in which case all of the type's methods are considered as asynchronous. In terms of target method signatures, any parameter types are supported. However, the return type is constrained to either void or java.util.concurrent.Future. In the latter case, you may declare the more specific org.springframework.util.concurrent.ListenableFuture or java.util.concurrent.CompletableFuture types which allow for richer interaction with the asynchronous task and for immediate composition with further processing steps. A Future handle returned from the proxy will be an actual asynchronous Future that can be used to track the result of the asynchronous method execution. However, since the target method needs to implement the same signature, it will have to return a temporary Future handle that just passes a value through: e.g. Spring's AsyncResult, EJB 3.1's javax.ejb.AsyncResult, or java.util.concurrent.CompletableFuture.completedFuture(Object)." />
      <item value="Annotation that marks a method as a candidate for asynchronous execution. Can also be used at the type level, in which case all of the type's methods are considered as asynchronous.&#10;In terms of target method signatures, any parameter types are supported. However, the return type is constrained to either void or java.util.concurrent.Future. In the latter case, you may declare the more specific org.springframework.util.concurrent.ListenableFuture or java.util.concurrent.CompletableFuture types which allow for richer interaction with the asynchronous task and for immediate composition with further processing steps.&#10;A Future handle returned from the proxy will be an actual asynchronous Future that can be used to track the result of the asynchronous method execution. However, since the target method needs to implement the same signature, it will have to return a temporary Future handle that just passes a value through: e.g. Spring's AsyncResult, EJB 3.1's javax.ejb.AsyncResult, or java.util.concurrent.CompletableFuture.completedFuture(Object)." />
      <item value="template" />
      <item value="Need AND/OR between two predicate! /a/@href" />
      <item value="body Structure" />
      <item value="gearbox" />
      <item value="overall Dimensions" />
      <item value="wheel Base" />
      <item value="intake Form" />
      <item value="A universal match pattern ('/**') is defined before other patterns in the filter chain, causing them to be ignored. Please check the ordering in your &lt;security:http&gt; namespace or FilterChainProxy bean configuration" />
      <item value="loginid" />
      <item value="Resets the form data. Causes all form elements to be reset to their original value." />
      <item value="$" />
      <item value="model Ids" />
      <item value="dis Show Po Role" />
      <item value="Wrapper" />
      <item value="Used to establish initial head or SHARED marker" />
      <item value="Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState, setState and compareAndSetState is tracked with respect to synchronization. Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. Class AbstractQueuedSynchronizer does not implement any synchronization interface. Instead it defines methods such as acquireInterruptibly that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods. This class supports either or both a default exclusive mode and a shared mode. When acquired in exclusive mode, attempted acquires by other threads cannot succeed. Shared mode acquires by multiple threads may (but need not) succeed. This class does not &quot;understand&quot; these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well. Threads waiting in the different modes share the same FIFO queue. Usually, implementation subclasses support only one of these modes, but both can come into play for example in a ReadWriteLock. Subclasses that support only exclusive or only shared modes need not define the methods supporting the unused mode. This class defines a nested AbstractQueuedSynchronizer.ConditionObject class that can be used as a Condition implementation by subclasses supporting exclusive mode for which method isHeldExclusively reports whether synchronization is exclusively held with respect to the current thread, method release invoked with the current getState value fully releases this object, and acquire, given this saved state value, eventually restores this object to its previous acquired state. No AbstractQueuedSynchronizer method otherwise creates such a condition, so if this constraint cannot be met, do not use it. The behavior of AbstractQueuedSynchronizer.ConditionObject depends of course on the semantics of its synchronizer implementation." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="153" />
        <entry key="ENGLISH" value="154" />
        <entry key="RUSSIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CORSICAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>