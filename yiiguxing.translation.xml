<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="initialize Bean" />
      <item value="is Synthetic" />
      <item value="Create a new instance of a dynamically generated subclass implementing the * required lookups." />
      <item value="Method Injection not supported in SimpleInstantiationStrategy" />
      <item value="// Don't override the class with CGLIB if no overrides." />
      <item value="resolved" />
      <item value="Cglib Subclassing Instantiation Strategy" />
      <item value="Return the instantiation strategy to use for creating bean instances." />
      <item value="get Security Manager" />
      <item value="instantiate Using Factory Method" />
      <item value="resolve" />
      <item value="// Make sure bean class is actually resolved at this point." />
      <item value="&quot;autowire constructor&quot; (with constructor arguments by type) behavior. Also applied if explicit constructor argument values are specified, matching all remaining arguments with beans from the bean factory. This corresponds to constructor injection: In this mode, a Spring bean factory is able to host components that expect constructor-based dependency resolution." />
      <item value="autowire Constructor" />
      <item value="Need to determine the constructor..." />
      <item value="Instantiate the bean." />
      <item value="Bean Post Processors" />
      <item value="Give BeanPostProcessors a chance to return a proxy instead of the target bean instance." />
      <item value="Prepare method overrides." />
      <item value="Root Bean Definition" />
      <item value="Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc." />
      <item value="// Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition." />
      <item value="Eagerly check singleton cache for manually registered singletons." />
      <item value="Check if bean definition exists in this factory." />
      <item value="// Fail if we're already creating this bean instance: // We're assumably within a circular reference." />
      <item value="assert Bean Factory Active ();" />
      <item value="nitialize LoadTimeWeaverAware beans early to allow for registering their transformers early." />
      <item value="// Initialize conversion service for this context." />
      <item value="Check for listener beans and register them." />
      <item value="Initialize other special beans in specific context subclasses." />
      <item value="Initialize event multicaster for this context." />
      <item value="Initialize message source for this context." />
      <item value="Register bean processors that intercept bean creation." />
      <item value="Register" />
      <item value="Invoke factory processors registered as beans in the context." />
      <item value="// Allows post-processing of the bean factory in context subclasses." />
      <item value="post Process" />
      <item value="post" />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Prepare the bean factory for use in this context." />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Prepare this context for refreshing." />
      <item value="Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown." />
      <item value="Store context in local instance variable, to guarantee that" />
      <item value="invoke" />
      <item value="Aware" />
      <item value="populate" />
      <item value="populate Bean" />
      <item value="denied" />
      <item value="command" />
    </histories>
  </component>
</application>