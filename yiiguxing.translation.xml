<application>
  <component name="AppStorage">
    <histories>
      <item value="The iteration ordering method for this linked hash map: true for access-order, false for insertion-order." />
      <item value="The iteration ordering method for this linked hash map:" />
      <item value="access Order" />
      <item value="deal Amount Dif" />
      <item value="Like addEntry except that this version is used when creating entries as part of Map construction or &quot;pseudo-construction&quot; (cloning, deserialization). This version needn't worry about resizing the table. Subclass overrides this to alter the behavior of HashMap(Map), clone, and readObject." />
      <item value="bucket Index" />
      <item value="This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor)." />
      <item value="assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;" />
      <item value="Initialize the hashing mask value. We defer initialization until we * really need it." />
      <item value="init Hash Seed As Needed" />
      <item value="round Up To Power Of 2" />
      <item value="Inflates" />
      <item value="inflate Table" />
      <item value="threshold" />
      <item value="Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;." />
      <item value="transfer" />
      <item value="Initialization hook for subclasses. This method is called * in all constructors and pseudo-constructors (clone, readObject) * after HashMap has been initialized but before any entries have * been inserted. (In the absence of this method, readObject would * require explicit knowledge of subclasses.)" />
      <item value="A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. If 0 then * alternative hashing is disabled." />
      <item value="hash Seed" />
      <item value="holds values which can't be initialized until after VM is booted." />
      <item value="An empty table instance to share when the table is not inflated." />
      <item value="The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30." />
      <item value="MAXIMUM CAPACITY" />
      <item value="The default initial capacity - MUST be a power of two." />
      <item value="This class provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface. To implement an unmodifiable map, the programmer needs only to extend this class and provide an implementation for the entrySet method, which returns a set-view of the map's mappings. Typically, the returned set will, in turn, be implemented atop AbstractSet. This set should not support the add or remove methods, and its iterator should not support the remove method. To implement a modifiable map, the programmer must additionally override this class's put method (which otherwise throws an UnsupportedOperationException), and the iterator returned by entrySet().iterator() must additionally implement its remove method. The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the Map interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the map being implemented admits a more efficient implementation. This class is a member of the Java Collections Framework." />
      <item value="Abstract Map" />
      <item value="Navigable Map" />
      <item value="distinguishes this * constructor from other int, float constructor." />
      <item value="distinguishes this" />
      <item value="ignored (distinguishes this" />
      <item value="dummy" />
      <item value="Constructs a new, empty linked hash set. (This package private constructor is only used by LinkedHashSet.) The backing HashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor." />
      <item value="Dummy value to associate with an Object in the backing Map" />
      <item value="Neal Gafter" />
      <item value="Josh Bloch" />
      <item value="A collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element. As implied by its name, this interface models the mathematical set abstraction. The Set interface places additional stipulations, beyond those inherited from the Collection interface, on the contracts of all constructors and on the contracts of the add, equals and hashCode methods. Declarations for other inherited methods are also included here for convenience. (The specifications accompanying these declarations have been tailored to the Set interface, but they do not contain any additional stipulations.) The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above). Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set. A special case of this prohibition is that it is not permissible for a set to contain itself as an element. Some set implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the set may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as &quot;optional&quot; in the specification for this interface. This interface is a member of the Java Collections Framework." />
      <item value="719163" />
      <item value="Fixed date of January 1, 1970 (Gregorian)" />
      <item value="The ERA constant designating the Meiji era." />
      <item value="The ERA constant designating the era before Meiji." />
      <item value="JapaneseImperialCalendar implements a Japanese calendar system in which the imperial era-based year numbering is supported from the Meiji era. The following are the eras supported by this calendar system. ERA value Era name Since (in Gregorian) ------------------------------------------------------ 0 N/A N/A 1 Meiji 1868-01-01 midnight local time 2 Taisho 1912-07-30 midnight local time 3 Showa 1926-12-25 midnight local time 4 Heisei 1989-01-08 midnight local time ------------------------------------------------------ ERA value 0 specifies the years before Meiji and the Gregorian year values are used. Unlike GregorianCalendar, the Julian to Gregorian transition is not supported because it doesn't make any sense to the Japanese calendar systems used before Meiji. To represent the years before Gregorian year 1, 0 and negative values are used. The Japanese Imperial rescripts and government decrees don't specify how to deal with time differences for applying the era transitions. This calendar implementation assumes local time for all transitions." />
      <item value="Heisei" />
      <item value="Showa" />
      <item value="Taisho" />
      <item value="Meiji" />
      <item value="Masayoshi" />
      <item value="Okutsu" />
      <item value="Masayoshi Okutsu" />
      <item value="Imperial" />
      <item value="Japanese Imperial Calendar" />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>