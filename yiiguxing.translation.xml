<application>
  <component name="AppStorage">
    <histories>
      <item value="CALLABLE" />
      <item value="PREPARED" />
      <item value="STATEMENT" />
      <item value="All of React Native (JS, Obj-C sources, Android binaries) is installed from npm" />
      <item value="// NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files" />
      <item value="Do not place your application dependencies here; they belong" />
      <item value="Could not get resource 'https://jcenter.bintray.com/com/android/tools/build/gradle/2.3.3/gradle-2.3.3.pom'." />
      <item value="Remote host closed connection during handshake" />
      <item value="generation" />
      <item value="An implementation of {@link WebMvcConfigurer} with empty methods allowing * subclasses to override only the methods they're interested in." />
      <item value="@deprecated as of 5.0 {@link WebMvcConfigurer} has default methods (made * possible by a Java 8 baseline) and can be implemented directly without the * need for this adapter" />
      <item value="An implementation of WebMvcConfigurer with empty methods allowing subclasses to override only the methods they're interested in." />
      <item value="3 wiV Wg 7 Ad T" />
      <item value="Whether to build an aggregated report at the root, or build individual reports." />
      <item value="Set this to &amp;apos;true&amp;apos; to skip analysis" />
      <item value="The name of the goal for which to show help. If unspecified, all goals will be displayed" />
      <item value="If &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt;, display all settable properties for each goal." />
      <item value="Graphite" />
      <item value="Metric" />
      <item value="method" />
      <item value="Annotation that marks a method as a candidate for &lt;i&gt;asynchronous&lt;/i&gt; execution. * Can also be used at the type level, in which case all of the type's methods are * considered as asynchronous." />
      <item value="Annotation that marks a method as a candidate for asynchronous execution. Can also be used at the type level, in which case all of the type's methods are considered as asynchronous. In terms of target method signatures, any parameter types are supported. However, the return type is constrained to either void or java.util.concurrent.Future. In the latter case, the Future handle returned from the proxy will be an actual asynchronous Future that can be used to track the result of the asynchronous method execution. However, since the target method needs to implement the same signature, it will have to return a temporary Future handle that just passes the return value through: e.g. Spring's AsyncResult or EJB 3.1's" />
      <item value="sku code" />
      <item value="Invalid character found in method name. HTTP method names must be tokens" />
      <item value="FROM" />
      <item value="warehouse Sku" />
      <item value="spu Name" />
      <item value="@param region to merge * @return index of this region * @throws IllegalArgumentException if region contains fewer than 2 cells * @throws IllegalStateException if region intersects with a multi-cell array formula * @throws IllegalStateException if region intersects with an existing region on this sheet" />
      <item value="Adds a merged region of cells on a sheet." />
      <item value="declares multiple JSON fields named id" />
      <item value="signfor Outbound" />
      <item value="INSPECTION FILE" />
      <item value="recharge" />
      <item value="recharge Serial Number" />
      <item value="enter Receipt Order Info" />
      <item value="enter" />
      <item value="ente" />
      <item value="Deprecated" />
      <item value="abnormal" />
      <item value="abnormal Out" />
      <item value="IAreaService is not visible from class loader" />
      <item value="Loan Code (" />
      <item value="approval" />
      <item value="association" />
      <item value="collection" />
      <item value="set Delivered Money" />
      <item value="This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor)." />
      <item value="/** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */" />
      <item value="assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;" />
      <item value="Returns index for hash code h." />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>