<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="488" />
    <option name="newTranslationDialogWidth" value="793" />
    <option name="newTranslationDialogX" value="879" />
    <option name="newTranslationDialogY" value="486" />
    <histories>
      <item value="Creates builder object for construction of custom CloseableHttpClient instances." />
      <item value="Creates CloseableHttpClient instance with default configuration." />
      <item value="instance with default configuration based on ssytem properties." />
      <item value="Creates {@link CloseableHttpClient} instance that implements the most basic HTTP protocol support." />
      <item value="Unsupported operator attention:self." />
      <item value="The from part of the range query. Null indicates unbounded. In case lower bound is assigned to a string, we internally convert it to a {@link BytesRef} because in {@link RangeQueryBuilder} field are later parsed as {@link BytesRef} and we need internal representation of query to be equal regardless of whether it was created from XContent or via Java API." />
      <item value="Should the lower bound be included or not." />
      <item value="Should the lower bound be included or not. Defaults to &lt;tt&gt;true&lt;tt&gt;." />
      <item value="The to part of the range query. Null indicates unbounded." />
      <item value="get Verify Cert Info" />
      <item value="Creates a &lt;code&gt;FileInputStream&lt;code&gt; by opening a connection to an actual file, the file named by the path name &lt;code&gt;name&lt;code&gt; in the file system. A new &lt;code&gt;FileDescriptor&lt;code&gt; object is created to represent this file connection. &lt;p&gt; First, if there is a security manager, its &lt;code&gt;checkRead&lt;code&gt; method is called with the &lt;code&gt;name&lt;code&gt; argument as its argument. &lt;p&gt; If the named file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading then a &lt;code&gt;FileNotFoundException&lt;code&gt; is thrown." />
      <item value="the system-dependent file name." />
      <item value="Handler dispatch failed; nested exception is java.lang.NoClassDefFoundError: Could not initialize class cfca.sadk.lib.crypto.JCrypto" />
      <item value="A filter to filter only documents where a field exists in them." />
      <item value="clear order version expire" />
      <item value="validate Cash Lock" />
      <item value="STATEMENT" />
      <item value="STATEMENT ORDER" />
      <item value="application" />
      <item value="220111000014" />
      <item value="A list of tags for API documentation control. Tags can be used for logical grouping of operations by resources or any other qualifier. A non-empty value will override the value provided in value()." />
      <item value="remote stacktrace: Backtrace:" />
      <item value="uninstall Driver Event" />
      <item value="sign" />
      <item value="get Expire" />
      <item value="BASE CHAR NUMBER" />
      <item value="retrieve up to 10 causes" />
      <item value="Determines an output value based on an input value; a pre-Java-8 version of java.util.function.Function. The Functions class provides common functions and related utilites. See the Guava User Guide article on the use of Function. For Java 8+ users This interface is now a legacy type. Use java.util.function.Function (or the appropriate primitive specialization such as ToIntFunction) instead whenever possible. Otherwise, at least reduce explicit dependencies on this type by using lambda expressions or method references instead of classes, leaving your code easier to migrate in the future. To use an existing function (say, named function) in a context where the other type of function is expected, use the method reference function::apply. A future version of com.google.common.base.Function will be made to extend java.util.function.Function, making conversion code necessary only in one direction. At that time, this interface will be officially discouraged." />
      <item value="Injector" />
      <item value="Apollo Injector" />
      <item value="The comma-separated list of namespace names to integrate with Spring property sources. If not specified, then default to application namespace." />
      <item value="Apollo configuration section to integrate with Spring" />
      <item value="Interface that encapsulates event publication functionality. Serves as super-interface for ApplicationContext. 自: 1.1.1" />
      <item value="Use this annotation to register Apollo ConfigChangeListener." />
      <item value="Replacement for Class.forName() that also returns Class instances for primitives (e.g. &quot;int&quot;) and array class names (e.g. &quot;String[]&quot;). Furthermore, it is also capable of resolving inner class names in Java source style (e.g. &quot;java.lang.Thread.State&quot; instead of &quot;java.lang.ThreadState&quot;). 形参: name – the name of the Class" />
      <item value="parent Bean Factory" />
      <item value="prototype" />
      <item value="When used as a type-level annotation in conjunction with @Component, @Scope indicates the name of a scope to use for instances of the annotated type. When used as a method-level annotation in conjunction with @Bean, @Scope indicates the name of a scope to use for the instance returned from the method. NOTE: @Scope annotations are only introspected on the concrete bean class (for annotated components) or the factory method (for @Bean methods). In contrast to XML bean definitions, there is no notion of bean definition inheritance, and inheritance hierarchies at the class level are irrelevant for metadata purposes. In this context, scope means the lifecycle of an instance, such as singleton, prototype, and so forth. Scopes provided out of the box in Spring may be referred to using the SCOPE_ constants available in the ConfigurableBeanFactory and WebApplicationContext interfaces. To register additional custom scopes, see CustomScopeConfigurer." />
      <item value="RUNTIME" />
      <item value="Element Type" />
      <item value="Scope" />
      <item value="multi" />
      <item value="Annotation which indicates that a method parameter should be bound to a web request header. &lt;p&gt;Supported for annotated handler methods in Servlet and Portlet environments. &lt;p&gt;If the method parameter is {@link java.util.Map Map&amp;lt;String, String&amp;gt;}, {@link org.springframework.util.MultiValueMap MultiValueMap&amp;lt;String, String&amp;gt;}, or {@link org.springframework.http.HttpHeaders HttpHeaders} then the map is populated with all header names and values." />
      <item value="Request Header" />
      <item value="Marks a constructor, field, setter method or config method as to be autowired by Spring's dependency injection facilities. This is an alternative to the JSR-330 javax.inject.Inject annotation, adding required-vs-optional semantics. Only one constructor (at max) of any given bean class may declare this annotation with the 'required' parameter set to true, indicating the constructor to autowire when used as a Spring bean. If multiple non-required constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primarydefault constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public. Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public. Config methods may have an arbitrary name and any number of arguments; each of those arguments will be autowired with a matching bean in the Spring container. Bean property setter methods are effectively just a special case of such a general config method. Such config methods do not have to be public. In the case of a multi-arg constructor or method, the 'required' parameter is applicable to all arguments. Individual parameters may be declared as Java-8-style java.util.Optional or, as of Spring Framework 5.0, also as @Nullable or a not-null parameter type in Kotlin, overriding the base required semantics. In case of a java.util.Collection or java.util.Map dependency type, the container autowires all beans matching the declared value type. For such purposes, the map keys must be declared as type String which will be resolved to the corresponding bean names. Such a container-provided collection will be ordered, taking into account org.springframework.core.Orderedorg.springframework.core.annotation.Order values of the target components, otherwise following their registration order in the container. Alternatively, a single matching target bean may also be a generally typed Collection or Map itself, getting injected as such. Note that actual injection is performed through a BeanPostProcessor which in turn means that you cannot use @Autowired to inject references into BeanPostProcessor or BeanFactoryPostProcessor types. Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor class (which, by default, checks for the presence of this annotation). 自: 2.5 请参阅: AutowiredAnnotationBeanPostProcessor, Qualifier, Value Gradle: org.springframework:spring-beans:5.0.10.RELEASE (spring-beans-5.0.10.RELEASE.jar)" />
      <item value="Count Down Latch" />
      <item value="auxiliary Unit" />
      <item value="hget All" />
      <item value="true to check for existence, false to check for absence" />
      <item value="org.openqa.selenium.WebDriverException: chrome not reachable (Session info: chrome=96.0.4664.93) Build info: version: '3.9.1', revision: '63f7b50', time: '2018-02-07T22:25:02.294Z' System info: host: 'KP', ip: '192.168.9.167', os.name: 'Windows 10', os.arch: 'amd64', os.version: '10.0', java.version: '1.8.0_201' Driver info: org.openqa.selenium.chrome.ChromeDriver Capabilities {acceptInsecureCerts: false, browserName: chrome, browserVersion: 96.0.4664.93, chrome: {chromedriverVersion: 96.0.4664.35 (8df3babf8da8f..., userDataDir: C:\Users\qinghui\AppData\Lo...}, goog:chromeOptions: {debuggerAddress: localhost:49733}, javascriptEnabled: true, networkConnectionEnabled: false, pageLoadStrategy: normal, platform: WINDOWS, platformName: WINDOWS, proxy: Proxy(), setWindowRect: true, strictFileInteractability: false, timeouts: {implicit: 0, pageLoad: 300000, script: 30000}, unhandledPromptBehavior: dismiss and notify, webauthn:extension:credBlob: true, webauthn:extension:largeBlob: true, webauthn:virtualAuthenticators: true} Session ID: a947e318414c417f0e9380ee78b31b01 Element info: {Using=id, value=loginSub} 检查信息: 报告测试中失败的方法调用或断言。 它有助于更快地检测代码中失败的行，并立即开始调试。 示例： @Test fun foo() { assertEquals(1, 0) 高亮显示 }" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2292" />
        <entry key="ENGLISH" value="2293" />
        <entry key="ARABIC" value="1" />
        <entry key="IRISH" value="2" />
        <entry key="BULGARIAN" value="9" />
        <entry key="ICELANDIC" value="1" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="1" />
        <entry key="RUSSIAN" value="3" />
        <entry key="FRENCH" value="20" />
        <entry key="FINNISH" value="2" />
        <entry key="HAUSA" value="1" />
        <entry key="DUTCH" value="10" />
        <entry key="CATALAN" value="4" />
        <entry key="CORSICAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="7" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALTESE" value="1" />
        <entry key="MALAY" value="3" />
        <entry key="NORWEGIAN" value="3" />
        <entry key="SWEDISH" value="5" />
        <entry key="SAMOAN" value="1" />
        <entry key="SLOVAK" value="2" />
        <entry key="SOMALI" value="1" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="3" />
        <entry key="GREEK" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="1" />
        <entry key="SUNDANESE" value="1" />
        <entry key="INDONESIAN" value="4" />
        <entry key="JAVANESE" value="2" />
        <entry key="VIETNAMESE" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1646383026672" />
  </component>
  <component name="Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAIfwSYUEMm05AS" />
      </app-key>
    </option>
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20220105001047030" />
      </app-key>
    </option>
  </component>
</application>