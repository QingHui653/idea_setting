<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="moved to" />
      <item value="as well as" />
      <item value="NamespaceHandler for the aop namespace." />
      <item value="In 2.0 XSD as well as in 2.1 XSD." />
      <item value="moved to context namespace as of 2.1" />
      <item value="Only in 2.0 XSD" />
      <item value="Loads the bean definitions via an XmlBeanDefinitionReader." />
      <item value="then proceed with actually loading the bean definitions." />
      <item value="Allow a subclass to provide custom initialization of the reader," />
      <item value="&quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;." />
      <item value="Parse the elements at the root level in the document:" />
      <item value="Propagate refresh to lifecycle processor first." />
      <item value="Publish the final event." />
      <item value="/** * Template method which can be overridden to add context-specific refresh work. * Called on initialization of special beans, before instantiation of singletons. * &lt;p&gt;This implementation is empty. * @throws BeansException in case of errors * @see #refresh() */" />
      <item value="Initialize other special beans in specific context subclasses." />
      <item value="/** * Modify the application context's internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for registering special * BeanPostProcessors etc in certain ApplicationContext implementations. * @param beanFactory the bean factory used by the application context */" />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Must generate CGLIB subclass." />
      <item value="Don't override the class with CGLIB if no overrides." />
      <item value="instantiate" />
      <item value="Trigger post-initialization callback for all applicable beans..." />
      <item value="Eagerly check singleton cache for manually registered singletons." />
      <item value="Trigger initialization of all non-lazy singleton beans..." />
      <item value="Eager" />
      <item value="is Eager Init" />
      <item value="remaining" />
      <item value="Instantiate" />
      <item value="temporary" />
      <item value="Allow for caching all bean definition metadata, not expecting further changes." />
      <item value="/ Allow for caching all bean definition metadata, not expecting further changes." />
      <item value="Stop using the temporary ClassLoader for type matching." />
      <item value="Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early." />
      <item value="Instantiate all remaining (non-lazy-init) singletons." />
      <item value="to perform a thread-safe type conversion using this system." />
      <item value="A service interface for type conversion. This is the entry point into the convert system." />
      <item value="Initialize conversion service for this context." />
      <item value="Check for listener beans and register them." />
      <item value="register Listeners" />
      <item value="subclasses" />
      <item value="For subclasses: do nothing by default." />
      <item value="finish Bean Factory Initialization" />
      <item value="Default implementation of the org.springframework.beans.factory.ListableBeanFactory and BeanDefinitionRegistry interfaces: a full-fledged bean factory based on bean definition objects. Typical usage is registering all bean definitions first (possibly read from a bean definition file), before accessing beans. Bean definition lookup is therefore an inexpensive operation in a local bean definition table, operating on pre-built bean definition metadata objects. Can be used as a standalone bean factory, or as a superclass for custom bean factories. Note that readers for specific bean definition formats are typically implemented separately rather than as bean factory subclasses: see for example PropertiesBeanDefinitionReader and org.springframework.beans.factory.xml.XmlBeanDefinitionReader. For an alternative implementation of the org.springframework.beans.factory.ListableBeanFactory interface, have a look at StaticListableBeanFactory, which manages existing bean instances rather than creating new ones based on bean definitions." />
      <item value="set Serialization Id" />
      <item value="Default Listable Bean Factory" />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Validate that all properties marked as required are resolvable" />
      <item value="&gt;Replace any stub property sources with actual instances." />
      <item value="Initialize any placeholder property sources in the context environment" />
      <item value="see ConfigurablePropertyResolver#setRequiredProperties" />
      <item value="Initialize message source for this context." />
    </histories>
  </component>
</application>