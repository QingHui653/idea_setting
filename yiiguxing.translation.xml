<application>
  <component name="AppStorage">
    <histories>
      <item value="An unbounded TransferQueue based on linked nodes. This queue orders elements FIFO (first-in-first-out) with respect to any given producer. The head of the queue is that element that has been on the queue the longest time for some producer. The tail of the queue is that element that has been on the queue the shortest time for some producer. Beware that, unlike in most collections, the size method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal. Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a LinkedTransferQueue happen-before actions subsequent to the access or removal of that element from the LinkedTransferQueue in another thread. This class is a member of the Java Collections Framework." />
      <item value="Linked Transfer Queue" />
      <item value="An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks, you might use: Executor executor = anExecutor; executor.execute(new RunnableTask1()); executor.execute(new RunnableTask2()); ... However, the Executor interface does not strictly require that execution be asynchronous. In the simplest case, an executor can run the submitted task immediately in the caller's thread: class DirectExecutor implements Executor { public void execute(Runnable r) { r.run(); } } More typically, tasks are executed in some thread other than the caller's thread. The executor below spawns a new thread for each task. class ThreadPerTaskExecutor implements Executor { public void execute(Runnable r) { new Thread(r).start(); } } Many Executor implementations impose some sort of limitation on how and when tasks are scheduled. The executor below serializes the submission of tasks to a second executor, illustrating a composite executor. class SerialExecutor implements Executor { final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;(); final Executor executor; Runnable active; SerialExecutor(Executor executor) { this.executor = executor; } public synchronized void execute(final Runnable r) { tasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (active == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((active = tasks.poll()) != null) { executor.execute(active); } } } The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors. Memory consistency effects: Actions in a thread prior to submitting a Runnable object to an Executor happen-before its execution begins, perhaps in another thread." />
      <item value="The iteration ordering method for this linked hash map: true for access-order, false for insertion-order." />
      <item value="The iteration ordering method for this linked hash map:" />
      <item value="access Order" />
      <item value="deal Amount Dif" />
      <item value="Like addEntry except that this version is used when creating entries as part of Map construction or &quot;pseudo-construction&quot; (cloning, deserialization). This version needn't worry about resizing the table. Subclass overrides this to alter the behavior of HashMap(Map), clone, and readObject." />
      <item value="bucket Index" />
      <item value="This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor)." />
      <item value="assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;" />
      <item value="Initialize the hashing mask value. We defer initialization until we * really need it." />
      <item value="init Hash Seed As Needed" />
      <item value="round Up To Power Of 2" />
      <item value="Inflates" />
      <item value="inflate Table" />
      <item value="threshold" />
      <item value="Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;." />
      <item value="transfer" />
      <item value="Initialization hook for subclasses. This method is called * in all constructors and pseudo-constructors (clone, readObject) * after HashMap has been initialized but before any entries have * been inserted. (In the absence of this method, readObject would * require explicit knowledge of subclasses.)" />
      <item value="A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. If 0 then * alternative hashing is disabled." />
      <item value="hash Seed" />
      <item value="holds values which can't be initialized until after VM is booted." />
      <item value="An empty table instance to share when the table is not inflated." />
      <item value="The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30." />
      <item value="MAXIMUM CAPACITY" />
      <item value="The default initial capacity - MUST be a power of two." />
      <item value="This class provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface. To implement an unmodifiable map, the programmer needs only to extend this class and provide an implementation for the entrySet method, which returns a set-view of the map's mappings. Typically, the returned set will, in turn, be implemented atop AbstractSet. This set should not support the add or remove methods, and its iterator should not support the remove method. To implement a modifiable map, the programmer must additionally override this class's put method (which otherwise throws an UnsupportedOperationException), and the iterator returned by entrySet().iterator() must additionally implement its remove method. The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the Map interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the map being implemented admits a more efficient implementation. This class is a member of the Java Collections Framework." />
      <item value="Abstract Map" />
      <item value="Navigable Map" />
      <item value="distinguishes this * constructor from other int, float constructor." />
      <item value="distinguishes this" />
      <item value="ignored (distinguishes this" />
      <item value="dummy" />
      <item value="Constructs a new, empty linked hash set. (This package private constructor is only used by LinkedHashSet.) The backing HashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor." />
      <item value="Dummy value to associate with an Object in the backing Map" />
      <item value="Neal Gafter" />
      <item value="Josh Bloch" />
      <item value="A collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element. As implied by its name, this interface models the mathematical set abstraction. The Set interface places additional stipulations, beyond those inherited from the Collection interface, on the contracts of all constructors and on the contracts of the add, equals and hashCode methods. Declarations for other inherited methods are also included here for convenience. (The specifications accompanying these declarations have been tailored to the Set interface, but they do not contain any additional stipulations.) The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above). Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set. A special case of this prohibition is that it is not permissible for a set to contain itself as an element. Some set implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the set may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as &quot;optional&quot; in the specification for this interface. This interface is a member of the Java Collections Framework." />
      <item value="719163" />
      <item value="Fixed date of January 1, 1970 (Gregorian)" />
      <item value="The ERA constant designating the Meiji era." />
      <item value="The ERA constant designating the era before Meiji." />
      <item value="JapaneseImperialCalendar implements a Japanese calendar system in which the imperial era-based year numbering is supported from the Meiji era. The following are the eras supported by this calendar system. ERA value Era name Since (in Gregorian) ------------------------------------------------------ 0 N/A N/A 1 Meiji 1868-01-01 midnight local time 2 Taisho 1912-07-30 midnight local time 3 Showa 1926-12-25 midnight local time 4 Heisei 1989-01-08 midnight local time ------------------------------------------------------ ERA value 0 specifies the years before Meiji and the Gregorian year values are used. Unlike GregorianCalendar, the Julian to Gregorian transition is not supported because it doesn't make any sense to the Japanese calendar systems used before Meiji. To represent the years before Gregorian year 1, 0 and negative values are used. The Japanese Imperial rescripts and government decrees don't specify how to deal with time differences for applying the era transitions. This calendar implementation assumes local time for all transitions." />
      <item value="Heisei" />
      <item value="Showa" />
      <item value="Taisho" />
      <item value="Meiji" />
      <item value="Masayoshi" />
      <item value="Okutsu" />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>