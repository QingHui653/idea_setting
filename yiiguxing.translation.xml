<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="Authorization" />
      <item value="avoid getfield opcode" />
      <item value="/** * Concatenates the specified string to the end of this string. * &lt;p&gt; * If the length of the argument string is &lt;code&gt;0&lt;/code&gt;, then this * &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a new * &lt;code&gt;String&lt;/code&gt; object is created, representing a character * sequence that is the concatenation of the character sequence * represented by this &lt;code&gt;String&lt;/code&gt; object and the character * sequence represented by the argument string.&lt;p&gt; * Examples: * &lt;blockquote&gt;&lt;pre&gt; * &quot;cares&quot;.concat(&quot;s&quot;) returns &quot;caress&quot; * &quot;to&quot;.concat(&quot;get&quot;).concat(&quot;her&quot;) returns &quot;together&quot; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param str the &lt;code&gt;String&lt;/code&gt; that is concatenated to the end * of this &lt;code&gt;String&lt;/code&gt;. * @return a string that represents the concatenation of this object's * characters followed by the string argument's characters." />
      <item value="sub Sequence" />
      <item value="Returns the index within this string of the first occurrence of the * specified substring." />
      <item value="Handles (rare) calls of lastIndexOf with a supplementary character." />
      <item value="Returns the index within this string of the last occurrence of the specified character. For values of ch in the range from 0 to 0xFFFF (inclusive), the index (in Unicode code units) returned is the largest value k such that: this.charAt(k) == ch is true. For other values of ch, it is the largest value k such that: this.codePointAt(k) == ch is true. In either case, if no such character occurs in this string, then -1 is returned. The String is searched backwards starting at the last character." />
      <item value="Handles (rare) calls of indexOf with a supplementary character." />
      <item value="Tests if two string regions are equal. A substring of this String object is compared to a substring of the argument other. The result is true if these substrings represent identical character sequences. The substring of this String object to be compared begins at index toffset and has length len. The substring of other to be compared begins at index ooffset and has length len. The result is false if and only if at least one of the following is true: toffset is negative. ooffset is negative. toffset+len is greater than the length of this String object. ooffset+len is greater than the length of the other argument. There is some nonnegative integer k less than len such that: this.charAt(toffset+k) != other.charAt(ooffset+k)" />
      <item value="No overflow because of numeric promotion" />
      <item value="equals Ignore Case" />
      <item value="Argument is a StringBuffer, StringBuilder" />
      <item value="content Equals" />
      <item value="content" />
      <item value="handle most cases here (ch is a BMP code point or a // negative value (invalid code point))" />
      <item value="Note: toffset might be near -1&gt;&gt;&gt;1." />
      <item value="pa" />
      <item value="Returns the character (Unicode code point) at the specified index. The index refers to char values (Unicode code units) and ranges from 0 to length() - 1. If the char value specified at the given index is in the high-surrogate range, the following index is less than the length of this String, and the char value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the char value at the given index is returned." />
      <item value="/* Common private utility method used to bounds check the byte array * and requested offset &amp; length values used by the String(byte[],..) * constructors. */" />
      <item value="rotate Right" />
      <item value="Returns the value obtained by reversing the order of the bits in the * two's complement binary representation of the specified {@code int} * value." />
      <item value="Returns the signum function of the specified {@code int} value. (The * return value is -1 if the specified value is negative; 0 if the * specified value is zero; and 1 if the specified value is positive.)" />
      <item value="HD, Section 2-7" />
      <item value="signum" />
      <item value="interoperability" />
      <item value="Returns the value obtained by reversing the order of the bytes in the * two's complement representation of the specified {@code int} value." />
      <item value="reverse Bytes" />
      <item value="rotate" />
      <item value="highest One Bit" />
      <item value="** * Compares two {@code int} values numerically. * The value returned is identical to what would be returned by: * &lt;pre&gt; * Integer.valueOf(x).compareTo(Integer.valueOf(y)) * &lt;/pre&gt; * * @param x the first {@code int} to compare * @param y the second {@code int} to compare * @return the value {@code 0} if {@code x == y}; * a value less than {@code 0} if {@code x &lt; y}; and * a value greater than {@code 0} if {@code x &gt; y} * @since 1.7 */" />
      <item value="Handle radix specifier, if present" />
      <item value="Decodes a {@code String} into an {@code Integer}. * Accepts decimal, hexadecimal, and octal numbers given * by the following grammar:" />
      <item value="Compares this object to the specified object. The result is * {@code true} if and only if the argument is not * {@code null} and is an {@code Integer} object that * contains the same {@code int} value as this object." />
      <item value="a hash code value for this object, equal to the * primitive {@code int} value represented by this * {@code Integer} object." />
      <item value="Returns a hash code for this {@code Integer}." />
      <item value="assert" />
      <item value="Integer" />
      <item value="high value may be configured by property" />
      <item value="does not contain a parsable" />
      <item value="Parses the string argument as a signed decimal integer. The * characters in the string must all be decimal digits, except * that the first character may be an ASCII minus sign {@code '-'} * (&lt;code&gt;'&amp;#92;u002D'&lt;/code&gt;) to indicate a negative value or an * ASCII plus sign {@code '+'} (&lt;code&gt;'&amp;#92;u002B'&lt;/code&gt;) to * indicate a positive value. The resulting integer value is * returned, exactly as if the argument and the radix 10 were * given as arguments to the {@link #parseInt(java.lang.String, * int)} method." />
      <item value="Accumulating negatively avoids surprises near MAX_VALUE" />
      <item value="Possible leading" />
      <item value="digit" />
      <item value="multmin" />
      <item value="negative" />
      <item value="Parses the string argument as a signed integer in the radix specified by the second argument. The characters in the string must all be digits of the specified radix (as determined by whether Character.digit(char, int) returns a nonnegative value), except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value or an ASCII plus sign '+' ('\u002B') to indicate a positive value. The resulting integer value is returned. An exception of type NumberFormatException is thrown if any of the following situations occurs: The first argument is null or is a string of length zero. The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX. Any character of the string is not a digit of the specified radix, except that the first character may be a minus sign '-' ('\u002D') or plus sign '+' ('\u002B') provided that the string is longer than length 1. The value represented by the string is not a value of type int." />
      <item value="really" />
      <item value="(q * 100);" />
      <item value="digits" />
      <item value="Places characters representing the integer i into the * character array buf. The characters are placed into * the buffer backwards starting with the least significant * digit at the specified index (exclusive), and working * backwards from there." />
    </histories>
  </component>
</application>