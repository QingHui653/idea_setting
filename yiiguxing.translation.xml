<application>
  <component name="AppStorage">
    <histories>
      <item value="Doug Lea" />
      <item value="segment Mask" />
      <item value="segment Shift" />
      <item value="Find power-of-two sizes best matching arguments" />
      <item value="nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment" />
      <item value="Returns the segment for the given index, creating it and * recording in segment table (via CAS) if not already present." />
      <item value="ensure Segment" />
      <item value="Gets the jth element of given segment array (if nonnull) with * volatile element access semantics via Unsafe. (The null check * can trigger harmlessly only during deserialization.) Note: * because each element of segments array is set only once (using * fully ordered writes), some performance-sensitive methods rely * on this method only as a recheck upon null reads." />
      <item value="segment At" />
      <item value="available Processors" />
      <item value="MAX SCAN RETRIES" />
      <item value="Segments are specialized versions of hash tables. This * subclasses from ReentrantLock opportunistically, just to * simplify some locking and avoid separate construction." />
      <item value="Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash." />
      <item value="Sets the ith element of given table, with volatile write * semantics. (See above about use of putOrderedObject.)" />
      <item value="Gets the ith element of given table (if nonnull) with volatile * read semantics. Note: This is manually integrated into a few * performance-sensitive methods to reduce call overhead." />
      <item value="threshold" />
      <item value="Reentrant Lock" />
      <item value="segments" />
      <item value="The segments, each of which is a specialized hash table." />
      <item value="Shift value for indexing within segments." />
      <item value="Mask value for indexing into segments. The upper bits of a * key's hash code are used to choose the segment." />
      <item value="positive" />
      <item value="behaviour is &quot;ON&quot; or &quot;OFF&quot;." />
      <item value="Use the &quot;threshold&quot; system property even though our threshold" />
      <item value="even" />
      <item value="dummy" />
      <item value="Dummy" />
      <item value="NULL" />
      <item value="odd Even List" />
      <item value="odes 为节点总数。" />
      <item value="holds values which can't be initialized until after VM is booted." />
      <item value="Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result." />
      <item value="RETRIES" />
      <item value="RETRIES BEFORE LOCK" />
      <item value="slightly conservative" />
      <item value="The maximum number of segments to allow; used to bound * constructor arguments. Must be power of two less than 1 &lt;&lt; 24." />
      <item value="SCAN" />
      <item value="MAX SEGMENTS" />
      <item value="concurrency Level" />
      <item value="MIN SEGMENT TABLE CAPACITY" />
      <item value="The default concurrency level for this table, used when not * otherwise specified in a constructor." />
      <item value="DEFAULT CONCURRENCY LEVEL" />
      <item value="A hash table supporting full concurrency of retrievals and * adjustable expected concurrency for updates. This class obeys the * same functional specification as {@link java.util.Hashtable}, and * includes versions of methods corresponding to each method of * &lt;tt&gt;Hashtable&lt;/tt&gt;. However, even though all operations are * thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking, * and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table * in a way that prevents all access. This class is fully * interoperable with &lt;tt&gt;Hashtable&lt;/tt&gt; in programs that rely on its * thread safety but not on its synchronization details." />
      <item value="find By Condition" />
      <item value="The iteration ordering method for this linked hash map:" />
      <item value="&lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order." />
      <item value="for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order." />
      <item value="The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;" />
      <item value="The head of the doubly linked list." />
      <item value="Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="544" />
        <entry key="ENGLISH" value="545" />
        <entry key="ARABIC" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="CATALAN" value="1" />
        <entry key="CORSICAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>