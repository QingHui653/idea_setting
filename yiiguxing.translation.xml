<application>
  <component name="AppStorage">
    <histories>
      <item value="trans Multi Line 2 One Line Str" />
      <item value="{ Pair&lt;V&gt; current = pair; if (newReference != current.reference || newMark != current.mark) this.pair = Pair.of(newReference, newMark); }" />
      <item value="new Reference" />
      <item value="new" />
      <item value="Atomic Markable Reference" />
      <item value="with the given" />
      <item value="apply As Long" />
      <item value="public final long getAndDecrement() { return unsafe.getAndAddLong(this, valueOffset, -1L); }" />
      <item value="public final long getAndAdd(long delta) { return unsafe.getAndAddLong(this, valueOffset, delta); }" />
      <item value="get And Add Long" />
      <item value="get And Increment" />
      <item value="public final boolean weakCompareAndSet(long expect, long update) { return unsafe.compareAndSwapLong(this, valueOffset, expect, update); }" />
      <item value="weak Compare And Set" />
      <item value="Returns whether underlying JVM supports lockless CompareAndSet * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS." />
      <item value="Records whether the underlying JVM supports lockless * compareAndSwap for longs. While the Unsafe.compareAndSwapLong * method works in either case, some constructions should be * handled at Java level to avoid locking user-visible locks." />
      <item value="Must be volatile type" />
      <item value="Must be integer type" />
      <item value="Atomically adds the given value to the current value of the field of * the given object managed by this updater." />
      <item value="An {@code int} array in which elements may be updated atomically. * See the {@link java.util.concurrent.atomic} package * specification for description of the properties of atomic * variables." />
      <item value="Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * * &lt;p&gt;&lt;a href=&quot;package-summary.html#weakCompareAndSet&quot;&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to {@code compareAndSet}." />
      <item value="Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value" />
      <item value="Sets to the given value. * * @param newValue the new value" />
      <item value="Creates a new AtomicInteger with initial value {@code 0}." />
      <item value="expect" />
      <item value="Creates a new {@code AtomicBoolean} with the given initial value." />
      <item value="valueOffset = unsafe.objectFieldOffset (AtomicBoolean.class.getDeclaredField(&quot;value&quot;));" />
      <item value="setup to use Unsafe.compareAndSwapInt for updates" />
      <item value="The minimum array length below which a parallel sorting * algorithm will not further partition the sorting task. Using * smaller sizes typically results in memory contention across * tasks that makes parallel speedups unlikely." />
      <item value="MIN ARRAY SORT GRAN" />
      <item value="obsolete" />
      <item value="District Id" />
      <item value="Total Sale Debt" />
      <item value="during Debt" />
      <item value="Debt" />
      <item value="during Paid" />
      <item value="cur Debt" />
      <item value="get Total Sale Debt" />
      <item value="is Category Flag" />
      <item value="region" />
      <item value="covert And Complete Product" />
      <item value="process Conflict Products" />
      <item value="ReferenceQueue&lt;?&gt; queue = r.queue;" />
      <item value="enqueued (and even then removed)" />
      <item value="Check that since getting the lock this reference hasn't already been" />
      <item value="lock" />
      <item value="synchronized" />
      <item value="Called only by Reference class" />
      <item value="Reference queues, to which registered reference objects are appended by the * garbage collector after the appropriate reachability changes are detected." />
      <item value="Package-private; must be in same package as the Reference class" />
      <item value="Decrement i modulo len." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1364" />
        <entry key="ENGLISH" value="1365" />
        <entry key="ARABIC" value="1" />
        <entry key="IRISH" value="1" />
        <entry key="BULGARIAN" value="5" />
        <entry key="DANISH" value="2" />
        <entry key="RUSSIAN" value="2" />
        <entry key="FRENCH" value="6" />
        <entry key="HAUSA" value="1" />
        <entry key="CATALAN" value="3" />
        <entry key="CORSICAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="4" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="2" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="2" />
        <entry key="SOMALI" value="1" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="1" />
        <entry key="SUNDANESE" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>