<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="inout Type" />
      <item value="elapsed time patterns: [h],[m] and [s]" />
      <item value="for format which start with &quot;[DBNum1]&quot; or &quot;[DBNum2]&quot; or &quot;[DBNum3]&quot; could be a Chinese date" />
      <item value="Chinese" />
      <item value="date" />
      <item value="could be a Chinese date" />
      <item value="left-justified horizontal alignment" />
      <item value="Removal" />
      <item value="Aware" />
      <item value="Couldn't determine package version information." />
      <item value="You are running with Spring Security Core null" />
      <item value="determine" />
      <item value="protocol" />
      <item value="Since" />
      <item value="Modified" />
      <item value="character" />
      <item value="Deque" />
      <item value="Array Deque" />
      <item value="Sequenti" />
      <item value="This class provides a skeletal implementation of the Collection interface, to minimize the effort required to implement this interface. To implement an unmodifiable collection, the programmer needs only to extend this class and provide implementations for the iterator and size methods. (The iterator returned by the iterator method must implement hasNext and next.) To implement a modifiable collection, the programmer must additionally override this class's add method (which otherwise throws an UnsupportedOperationException), and the iterator returned by the iterator method must additionally implement its remove method. The programmer should generally provide a void (no argument) and Collection constructor, as per the recommendation in the Collection interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation." />
      <item value="consistent" />
      <item value="transitive" />
      <item value="symmetric" />
      <item value="reflexive" />
      <item value="register Natives" />
      <item value="An instance of ThreadDeath is thrown in the victim thread when the (deprecated) Thread.stop() method is invoked. An application should catch instances of this class only if it must clean up after being terminated asynchronously. If ThreadDeath is caught by a method, it is important that it be rethrown so that the thread actually dies." />
      <item value="The character properties are currently encoded into 32 bits in the following manner:" />
      <item value="overflow-conscious code" />
      <item value="ensure Capacity Internal" />
      <item value="ensure Capacity" />
      <item value="capacity" />
      <item value="A thread-safe, mutable sequence of characters. A string buffer is like a String, but can be modified. At any point in time it contains some particular sequence of characters, but the length and content of the sequence can be changed through certain method calls. String buffers are safe for use by multiple threads. The methods are synchronized where necessary so that all the operations on any particular instance behave as if they occur in some serial order that is consistent with the order of the method calls made by each of the individual threads involved. The principal operations on a StringBuffer are the append and insert methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string buffer. The append method always adds these characters at the end of the buffer; the insert method adds the characters at a specified point. For example, if z refers to a string buffer object whose current contents are &quot;start&quot;, then the method call z.append(&quot;le&quot;) would cause the string buffer to contain &quot;startle&quot;, whereas z.insert(4, &quot;le&quot;) would alter the string buffer to contain &quot;starlet&quot;. In general, if sb refers to an instance of a StringBuffer, then sb.append(x) has the same effect as sb.insert(sb.length(), x). Whenever an operation occurs involving a source sequence (such as appending or inserting from a source sequence), this class synchronizes only on the string buffer performing the operation, not on the source. Note that while StringBuffer is designed to be safe to use concurrently from multiple threads, if the constructor or the append or insert operation is passed a source sequence that is shared across threads, the calling code must ensure that the operation has a consistent and unchanging view of the source sequence for the duration of the operation. This could be satisfied by the caller holding a lock during the operation's call, by using an immutable source sequence, or by not sharing the source sequence across threads. Every string buffer has a capacity. As long as the length of the character sequence contained in the string buffer does not exceed the capacity, it is not necessary to allocate a new internal buffer array. If the internal buffer overflows, it is automatically made larger. Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown. As of release JDK 5, this class has been supplemented with an equivalent class designed for use by a single thread, StringBuilder. The StringBuilder class should generally be used in preference to this one, as it supports all of the same operations but it is faster, as it performs no synchronization." />
      <item value="Constructs a string buffer with no characters in it and an * initial capacity of 16 characters." />
      <item value="Now check if there are any characters that need to be changed." />
      <item value="/* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters &quot;.$|()[{^?*+\\&quot;, or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */" />
      <item value="Handles (rare) calls of lastIndexOf with a supplementary character." />
      <item value="supplementary" />
      <item value="Handles (rare) calls of indexOf with a supplementary character." />
      <item value="region Matches" />
      <item value="Note: offset or count might be near -1&gt;&gt;&gt;1." />
      <item value="Returns the value obtained by reversing the order of the bits in the two's complement binary representation of the specified int value." />
      <item value="reverse" />
      <item value="0 x 3 f" />
      <item value="Figure" />
      <item value="number Of Leading Zeros" />
      <item value="lowest One Bit" />
      <item value="highest One Bit" />
      <item value="Bit twiddling" />
      <item value="divide Unsigned" />
      <item value="Decodes a String into an Integer. Accepts decimal, hexadecimal, and octal numbers given by the following grammar: DecodableString: Signopt DecimalNumeral Signopt 0x HexDigits Signopt 0X HexDigits Signopt # HexDigits Signopt 0 OctalDigits Sign: - + DecimalNumeral, HexDigits, and OctalDigits are as defined in section 3.10.1 of The Javaâ„¢ Language Specification, except that underscores are not accepted between digits. The sequence of characters following an optional sign and/or radix specifier (&quot;0x&quot;, &quot;0X&quot;, &quot;#&quot;, or leading zero) is parsed as by the Integer.parseInt method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a NumberFormatException will be thrown. The result is negated if first character of the specified String is the minus sign. No whitespace characters are permitted in the String." />
    </histories>
  </component>
</application>