<application>
  <component name="AppStorage">
    <histories>
      <item value="lways use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies&quot;." />
      <item value="error Limit" />
      <item value="peek" />
      <item value="finance flow can not modify" />
      <item value="To Int Bi Function" />
      <item value="Constant for the &quot;CJK Compatibility Ideographs&quot; Unicode character * block." />
      <item value="Outlay" />
      <item value="query Customer Outlay" />
      <item value="Returns a stream consisting of the elements of this stream, sorted according to natural order. If the elements of this stream are not Comparable, a java.lang.ClassCastException may be thrown when the terminal operation is executed. For ordered streams, the sort is stable. For unordered streams, no stability guarantees are made. This is a stateful intermediate operation." />
      <item value="Returns a stream consisting of the elements of this stream, sorted according to natural order. If the elements of this stream are not Comparable, a java.lang.ClassCastException may be thrown when the terminal operation is executed.&#10;For ordered streams, the sort is stable. For unordered streams, no stability guarantees are made.&#10;This is a stateful intermediate operation." />
      <item value="先将ID排序，再分批次查询，一批100条" />
      <item value="Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)" />
      <item value="product No" />
      <item value="ELEMENT LEVEL" />
      <item value="product Spec Element Id 3" />
      <item value="product Spec Element Id 2" />
      <item value="product Spec Element Id 1" />
      <item value="Returns a possibly parallel Stream with this collection as its source. It is allowable for this method to return a sequential stream. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)" />
      <item value="Returns a possibly parallel Stream with this collection as its source. It is allowable for this method to return a sequential stream.&#10;This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)" />
      <item value="parallel Stream" />
      <item value="sequence" />
      <item value="invoke" />
      <item value="contract" />
      <item value="formatter" />
      <item value="A builder for creating Feign clients without using the {@link FeignClient} annotation. * &lt;p&gt; * This builder builds the Feign client exactly like it would be created by using the * {@link FeignClient} annotation." />
      <item value="A builder for creating Feign clients without using the {@link FeignClient} annotation. * &lt;p&gt;" />
      <item value="This builder builds the Feign client exactly like it would be created by using the * {@link FeignClient} annotation." />
      <item value="A builder for creating Feign clients without using the FeignClient annotation.&#10;This builder builds the Feign client exactly like it would be created by using the FeignClient annotation." />
      <item value="A factory that creates instances of feign classes. It creates a Spring * ApplicationContext per client name, and extracts the beans that it needs from there." />
      <item value="Allows an application to customize the Feign {@link FormattingConversionService}." />
      <item value="WARNING! Nothing in this class should be @Autowired. It causes NPEs because of some lifecycle race condition." />
      <item value="the bean factory to register with" />
      <item value="Register the given bean definition with the given bean factory." />
      <item value="verify annotated class is an interface" />
      <item value="Fallback class for the specified Feign client interface. The fallback class must * implement the interface annotated by this annotation and be a valid spring bean." />
      <item value="FIXME annotation.getAliasedString(&quot;name&quot;, FeignClient.class, null);" />
      <item value="This blows up if an aliased property is overspecified" />
      <item value="is Candidate Component" />
      <item value="Candidate" />
      <item value="This argument is required, it must not be null" />
      <item value="Helper class to create a {@link TypeFilter} that matches if all the delegates * match." />
      <item value="generic" />
      <item value="generic Bean Definition" />
      <item value="register Default Configuration" />
      <item value="Gang Li" />
      <item value="and RibbonClientsConfigurationRegistgrar" />
      <item value="patterned" />
      <item value="patterned after Spring Integration IntegrationComponentScanRegistrar" />
      <item value="add Constructor Arg Value" />
      <item value="Interface to be implemented by any object that wishes to be notified of the ResourceLoader (typically the ApplicationContext) that it runs in. This is an alternative to a full ApplicationContext dependency via the ApplicationContextAware interface.&#10;Note that Resource dependencies can also be exposed as bean properties of type Resource, populated via Strings with automatic type conversion by the bean factory. This removes the need for implementing any callback interface just for the purpose of accessing a specific file resource.&#10;You typically need a ResourceLoader when your application object has to access a variety of file resources whose names are calculated. A good strategy is to make the object use a DefaultResourceLoader but still implement ResourceLoaderAware to allow for overriding when running in an ApplicationContext. See ReloadableResourceBundleMessageSource for an example.&#10;A passed-in ResourceLoader can also be checked for the ResourcePatternResolver interface and cast accordingly, to be able to resolve resource patterns into arrays of Resource objects. This will always work when running in an ApplicationContext (the context interface extends ResourcePatternResolver). Use a PathMatchingResourcePatternResolver as default. See also the ResourcePatternUtils.getResourcePatternResolver method.&#10;As alternative to a ResourcePatternResolver dependency, consider exposing bean properties of type Resource array, populated via pattern Strings with automatic type conversion by the bean factory." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="923" />
        <entry key="ENGLISH" value="923" />
        <entry key="ARABIC" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="CATALAN" value="2" />
        <entry key="CORSICAN" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SLOVAK" value="2" />
        <entry key="WELSH" value="11" />
        <entry key="SPANISH" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="JAVANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>