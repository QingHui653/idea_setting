<application>
  <component name="AppStorage">
    <histories>
      <item value="surefire" />
      <item value="Start fixup at replacement node, if it exists." />
      <item value="Returns the successor of the specified Entry, or null if no such." />
      <item value="Delete node p, and then rebalance the tree." />
      <item value="If strictly internal, copy successor's element to p and then make p" />
      <item value="point to successor." />
      <item value="No children. Use self as phantom replacement and unlink." />
      <item value="return if we are the only node." />
      <item value="Link replacement to parent" />
      <item value="successor" />
      <item value="// If strictly internal, copy successor's element to p and then make p // point to successor." />
      <item value="p has 2 children" />
      <item value="Offload comparator-based version for sake of performance" />
      <item value="invalid or incomplete tag" />
      <item value="Fix replacement" />
      <item value="type (and possibly null) check" />
      <item value="company Id Elem" />
      <item value="bucunzaide" />
      <item value="Acquires the lock unless the current thread is interrupted. Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one. If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately. If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens: The lock is acquired by the current thread; or Some other thread interrupts the current thread. If the lock is acquired by the current thread then the lock hold count is set to one. If the current thread: has its interrupted status set on entry to this method; or is interrupted while acquiring the lock, then InterruptedException is thrown and the current thread's interrupted status is cleared. In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock." />
      <item value="Acquires the lock unless the current thread is interrupted.&#10;Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one.&#10;If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately.&#10;If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:&#10;The lock is acquired by the current thread; or&#10;Some other thread interrupts the current thread.&#10;If the lock is acquired by the current thread then the lock hold count is set to one.&#10;If the current thread:&#10;has its interrupted status set on entry to this method; or&#10;is interrupted while acquiring the lock,&#10;then InterruptedException is thrown and the current thread's interrupted status is cleared.&#10;In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock." />
      <item value="Number of elements in the queue" />
      <item value="Causes the current thread to wait until it is signalled or interrupted. The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens: Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or A &quot;spurious wakeup&quot; occurs. In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one." />
      <item value="Causes the current thread to wait until it is signalled or interrupted.&#10;The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:&#10;Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or&#10;Some other thread invokes the signalAll method for this Condition; or&#10;Some other thread interrupts the current thread, and interruption of thread suspension is supported; or&#10;A &quot;spurious wakeup&quot; occurs.&#10;In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock.&#10;If the current thread:&#10;has its interrupted status set on entry to this method; or&#10;is interrupted while waiting and interruption of thread suspension is supported,&#10;then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released.&#10;Implementation Considerations&#10;The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact.&#10;An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one." />
      <item value="Interruptibly" />
      <item value="Extracts element at current take position, advances, and signals. * Call only when holding lock." />
      <item value="Indicates that the named compiler warnings should be suppressed in the annotated element (and in all program elements contained in the annotated element). Note that the set of warnings suppressed in a given element is a superset of the warnings suppressed in all containing elements. For example, if you annotate a class to suppress one warning and annotate a method to suppress another, both warnings will be suppressed in the method. As a matter of style, programmers should always use this annotation on the most deeply nested element where it is effective. If you want to suppress a warning in a particular method, you should annotate that method rather than its class." />
      <item value="Indicates that the named compiler warnings should be suppressed in the annotated element (and in all program elements contained in the annotated element). Note that the set of warnings suppressed in a given element is a superset of the warnings suppressed in all containing elements. For example, if you annotate a class to suppress one warning and annotate a method to suppress another, both warnings will be suppressed in the method.&#10;As a matter of style, programmers should always use this annotation on the most deeply nested element where it is effective. If you want to suppress a warning in a particular method, you should annotate that method rather than its class." />
      <item value="SimpleDateFormat is a concrete class for formatting and parsing dates in a locale-sensitive manner. It allows for formatting (date → text), parsing (text → date), and normalization. SimpleDateFormat allows you to start by choosing any user-defined patterns for date-time formatting. However, you are encouraged to create a date-time formatter with either getTimeInstance, getDateInstance, or getDateTimeInstance in DateFormat. Each of these class methods can return a date/time formatter initialized with a default format pattern. You may modify the format pattern using the applyPattern methods as desired. For more information on using these methods, see DateFormat." />
      <item value="SimpleDateFormat is a concrete class for formatting and parsing dates in a locale-sensitive manner. It allows for formatting (date → text), parsing (text → date), and normalization.&#10;SimpleDateFormat allows you to start by choosing any user-defined patterns for date-time formatting. However, you are encouraged to create a date-time formatter with either getTimeInstance, getDateInstance, or getDateTimeInstance in DateFormat. Each of these class methods can return a date/time formatter initialized with a default format pattern. You may modify the format pattern using the applyPattern methods as desired. For more information on using these methods, see DateFormat." />
      <item value="Sets the category of the constructed Logger. By default, it will use the type where the annotation is placed." />
      <item value="A qualifier value for the specified asynchronous operation(s). May be used to determine the target executor to be used when executing this method, matching the qualifier value (or the bean name) of a specific Executor or TaskExecutor bean definition. When specified on a class level @Async annotation, indicates that the given executor should be used for all methods within the class. Method level use of Async#value always overrides any value set at the class level." />
      <item value="A qualifier value for the specified asynchronous operation(s).&#10;May be used to determine the target executor to be used when executing this method, matching the qualifier value (or the bean name) of a specific Executor or TaskExecutor bean definition.&#10;When specified on a class level @Async annotation, indicates that the given executor should be used for all methods within the class. Method level use of Async#value always overrides any value set at the class level." />
      <item value="/** * A qualifier value for the specified asynchronous operation(s). * &lt;p&gt;May be used to determine the target executor to be used when executing this * method, matching the qualifier value (or the bean name) of a specific * {@link java.util.concurrent.Executor Executor} or * {@link org.springframework.core.task.TaskExecutor TaskExecutor} * bean definition. * &lt;p&gt;When specified on a class level {@code @Async} annotation, indicates that the * given executor should be used for all methods within the class. Method level use * of {@code Async#value} always overrides any value set at the class level. * @since 3.1.2 */" />
      <item value="More than one TaskExecutor bean found within the context, and none is named &quot; + &quot;'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly &quot; + &quot;as an alias) in order to use it for async processing" />
      <item value="More than one TaskExecutor bean found within the context, and none is named &quot; + &quot;'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly &quot; + &quot;as an alias) in order to use it for async processing:" />
      <item value="Error creating bean with name 'SkuInfoService': Bean with name 'SkuInfoService' has been injected into other beans [SpuInfoService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example." />
      <item value="Delivery" />
      <item value="Invoked after all handler methods have been detected." />
      <item value="Deprecated as of 4.3, in favor of the HandlerMethod-based MVC infrastructure" />
      <item value="Provides a method for invoking the handler method for a given request after resolving its method argument values through registered HandlerMethodArgumentResolvers. Argument resolution often requires a WebDataBinder for data binding or for type conversion. Use the setDataBinderFactory(WebDataBinderFactory) property to supply a binder factory to pass to argument resolvers." />
      <item value="Support class for invoking an annotated handler method. Operates on the introspection results of a HandlerMethodResolver for a specific handler type. Used by org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter and org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter. Deprecated as of 4.3, in favor of the HandlerMethod-based MVC infrastructure" />
      <item value="Support class for invoking an annotated handler method. Operates on the introspection * results of a {@link HandlerMethodResolver} for a specific handler type." />
      <item value="Did the handler return a view to render?" />
      <item value="Apply postHandle methods of registered interceptors." />
      <item value="Actually invoke the handler." />
      <item value="No synchronization on session demanded at all..." />
      <item value="Determine handler for the current request" />
      <item value="Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch} * for the actual dispatching." />
      <item value="Initialize the HandlerMappings used by this class. * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace, * we default to BeanNameUrlHandlerMapping." />
      <item value="Initialize the HandlerMappings used by this class." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="30" />
        <entry key="ENGLISH" value="31" />
        <entry key="CATALAN" value="1" />
        <entry key="CORSICAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>