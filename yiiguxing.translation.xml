<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="Handles (rare) calls of lastIndexOf with a supplementary character." />
      <item value="character" />
      <item value="supplementary" />
      <item value="Handles (rare) calls of indexOf with a supplementary character." />
      <item value="region Matches" />
      <item value="Note: offset or count might be near -1&gt;&gt;&gt;1." />
      <item value="Returns the value obtained by reversing the order of the bits in the two's complement binary representation of the specified int value." />
      <item value="reverse" />
      <item value="0 x 3 f" />
      <item value="Figure" />
      <item value="number Of Leading Zeros" />
      <item value="lowest One Bit" />
      <item value="highest One Bit" />
      <item value="Bit twiddling" />
      <item value="divide Unsigned" />
      <item value="Decodes a String into an Integer. Accepts decimal, hexadecimal, and octal numbers given by the following grammar: DecodableString: Signopt DecimalNumeral Signopt 0x HexDigits Signopt 0X HexDigits Signopt # HexDigits Signopt 0 OctalDigits Sign: - + DecimalNumeral, HexDigits, and OctalDigits are as defined in section 3.10.1 of The Javaâ„¢ Language Specification, except that underscores are not accepted between digits. The sequence of characters following an optional sign and/or radix specifier (&quot;0x&quot;, &quot;0X&quot;, &quot;#&quot;, or leading zero) is parsed as by the Integer.parseInt method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a NumberFormatException will be thrown. The result is negated if first character of the specified String is the minus sign. No whitespace characters are permitted in the String." />
      <item value="The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class." />
      <item value="Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS." />
      <item value="Generate two digits per iteration" />
      <item value="get Chars" />
      <item value="I use the &quot;invariant division by multiplication&quot; trick to // accelerate Integer.toString. In particular we want to // avoid division by 10." />
      <item value="use the &quot;invariant division by multiplication&quot; trick to // accelerate Integer.toString. In particular we want to // avoid division by 10." />
      <item value="// I use the &quot;invariant division by multiplication&quot; trick to // accelerate Integer.toString. In particular we want to // avoid division by 10. // // The &quot;trick&quot; has roughly the same performance characteristics // as the &quot;classic&quot; Integer.toString code on a non-JIT VM. // The trick avoids .rem and .div calls but has a longer code // path and is thus dominated by dispatch overhead. In the // JIT case the dispatch overhead doesn't exist and the // &quot;trick&quot; is considerably faster than the classic code. // // TODO-FIXME: convert (x * 52429) into the equiv shift-add // sequence. // // RE: Division by Invariant Integers using Multiplication // T Gralund, P Montgomery // ACM PLDI 1994 //" />
      <item value="Digit Ones" />
      <item value="Digit Tens" />
      <item value="mag" />
      <item value="Convert the integer to an unsigned number." />
      <item value="Binary" />
      <item value="Hex" />
      <item value="Octal" />
      <item value="Hex S" />
      <item value="Unsigned" />
      <item value="nsigned" />
      <item value="Pos" />
      <item value="char Pos" />
      <item value="bound addresses" />
      <item value="An error report file with more information is saved as:" />
      <item value="Native memory allocation (mmap) failed to map 2060255232 bytes for committing reserved memory." />
      <item value="There is insufficient memory for the Java Runtime Environment to continue." />
      <item value="There is insufficient memory for the Java Runtime Environment to continue. # Native memory allocation (mmap) failed to map 986513408 bytes for committing reserved memory. # An error report file with more information is saved as: # /opt/elasticsearch/hs_err_pid74.log" />
      <item value="Starting Elasticsearch Server OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c5330000, 986513408, 0) failed; error='Cannot allocate memory' (errno=12)" />
      <item value="Lombok Requires Annotation Processing Annotation processing seems to be disabled for the project &quot;oms&quot;. For the plugin to function correctly, please enable it under" />
      <item value="Declared" />
      <item value="Handle sign, if present" />
      <item value="Maximum array size is Integer.MAX_VALUE" />
      <item value="high value may be configured by property" />
      <item value="size Table" />
      <item value="Returns a string representation of the first argument as an unsigned integer value in the radix specified by the second argument. If the radix is smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX, then the radix 10 is used instead. Note that since the first argument is treated as an unsigned value, no leading sign character is printed. If the magnitude is zero, it is represented by a single zero character '0' ('\u0030'); otherwise, the first character of the representation of the magnitude will not be the zero character. The behavior of radixes and the characters used as digits are the same as toString." />
      <item value="Returns the number of zero bits preceding the highest-order (&quot;leftmost&quot;) one-bit in the two's complement binary representation of the specified int value. Returns 32 if the specified value has no one-bits in its two's complement representation, in other words if it is equal to zero. Note that this method is closely related to the logarithm base 2. For all positive int values x: floor(log2(x)) = 31 - numberOfLeadingZeros(x) ceil(log2(x)) = 32 - numberOfLeadingZeros(x - 1)" />
      <item value="HD, Figure 5-6" />
    </histories>
  </component>
</application>