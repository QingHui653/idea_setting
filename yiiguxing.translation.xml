<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="CHINESE" />
    <histories>
      <item value="Propagate refresh to lifecycle processor first." />
      <item value="Publish the final event." />
      <item value="/** * Template method which can be overridden to add context-specific refresh work. * Called on initialization of special beans, before instantiation of singletons. * &lt;p&gt;This implementation is empty. * @throws BeansException in case of errors * @see #refresh() */" />
      <item value="Initialize other special beans in specific context subclasses." />
      <item value="/** * Modify the application context's internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for registering special * BeanPostProcessors etc in certain ApplicationContext implementations. * @param beanFactory the bean factory used by the application context */" />
      <item value="Allows post-processing of the bean factory in context subclasses." />
      <item value="Must generate CGLIB subclass." />
      <item value="Don't override the class with CGLIB if no overrides." />
      <item value="instantiate" />
      <item value="Trigger post-initialization callback for all applicable beans..." />
      <item value="Eagerly check singleton cache for manually registered singletons." />
      <item value="Trigger initialization of all non-lazy singleton beans..." />
      <item value="Eager" />
      <item value="is Eager Init" />
      <item value="remaining" />
      <item value="Instantiate" />
      <item value="temporary" />
      <item value="Allow for caching all bean definition metadata, not expecting further changes." />
      <item value="/ Allow for caching all bean definition metadata, not expecting further changes." />
      <item value="Stop using the temporary ClassLoader for type matching." />
      <item value="Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early." />
      <item value="Instantiate all remaining (non-lazy-init) singletons." />
      <item value="to perform a thread-safe type conversion using this system." />
      <item value="A service interface for type conversion. This is the entry point into the convert system." />
      <item value="Initialize conversion service for this context." />
      <item value="Check for listener beans and register them." />
      <item value="register Listeners" />
      <item value="subclasses" />
      <item value="For subclasses: do nothing by default." />
      <item value="finish Bean Factory Initialization" />
      <item value="Default implementation of the org.springframework.beans.factory.ListableBeanFactory and BeanDefinitionRegistry interfaces: a full-fledged bean factory based on bean definition objects. Typical usage is registering all bean definitions first (possibly read from a bean definition file), before accessing beans. Bean definition lookup is therefore an inexpensive operation in a local bean definition table, operating on pre-built bean definition metadata objects. Can be used as a standalone bean factory, or as a superclass for custom bean factories. Note that readers for specific bean definition formats are typically implemented separately rather than as bean factory subclasses: see for example PropertiesBeanDefinitionReader and org.springframework.beans.factory.xml.XmlBeanDefinitionReader. For an alternative implementation of the org.springframework.beans.factory.ListableBeanFactory interface, have a look at StaticListableBeanFactory, which manages existing bean instances rather than creating new ones based on bean definitions." />
      <item value="set Serialization Id" />
      <item value="Default Listable Bean Factory" />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Validate that all properties marked as required are resolvable" />
      <item value="&gt;Replace any stub property sources with actual instances." />
      <item value="Initialize any placeholder property sources in the context environment" />
      <item value="see ConfigurablePropertyResolver#setRequiredProperties" />
      <item value="Initialize message source for this context." />
      <item value="Synchronization monitor for the &quot;refresh&quot; and &quot;destroy&quot;" />
      <item value="fix bug" />
      <item value="Prepare this context for refreshing." />
      <item value="Standalone XML application context, taking the context definition files from the class path, interpreting plain paths as class path resource names that include the package path (e.g. &quot;mypackage/myresource.txt&quot;). Useful for test harnesses as well as for application contexts embedded within JARs. The config location defaults can be overridden via getConfigLocations, Config locations can either denote concrete files like &quot;/myfiles/context.xml&quot; or Ant-style patterns like &quot;/myfiles/*-context.xml&quot; (see the org.springframework.util.AntPathMatcher javadoc for pattern details). Note: In case of multiple config locations, later bean definitions will override ones defined in earlier loaded files. This can be leveraged to deliberately override certain bean definitions via an extra XML file." />
      <item value="Instantiate the root WebApplicationContext for this loader, either the default context class or a custom context class if specified. This implementation expects custom contexts to implement the ConfigurableWebApplicationContext interface. Can be overridden in subclasses. In addition, customizeContext gets called prior to refreshing the context, allowing subclasses to perform custom modifications to the context." />
      <item value="Create a new ContextLoaderListener that will create a web application context based on the &quot;contextClass&quot; and &quot;contextConfigLocation&quot; servlet context-params. See ContextLoader superclass documentation for details on default values for each. This constructor is typically used when declaring ContextLoaderListener as a &lt;listener&gt; within web.xml, where a no-arg constructor is required. The created application context will be registered into the ServletContext under the attribute name WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE and the Spring application context will be closed when the contextDestroyed lifecycle method is invoked on this listener." />
      <item value="Workspace is restored to how it was in the â€˜feature/StockCustomizeList' branch" />
      <item value="Implementing this interface makes sense for example when an object * requires access to a set of collaborating beans. Note that configuration * via bean references is preferable to implementing this interface just * for bean lookup purposes." />
      <item value="Interface to be implemented by any object that wishes to be notified of the ApplicationContext that it runs in. Implementing this interface makes sense for example when an object requires access to a set of collaborating beans. Note that configuration via bean references is preferable to implementing this interface just for bean lookup purposes. This interface can also be implemented if an object needs access to file resources, i.e. wants to call getResource, wants to publish an application event, or requires access to the MessageSource. However, it is preferable to implement the more specific ResourceLoaderAware, ApplicationEventPublisherAware or MessageSourceAware interface in such a specific scenario. Note that file resource dependencies can also be exposed as bean properties of type org.springframework.core.io.Resource, populated via Strings with automatic type conversion by the bean factory. This removes the need for implementing any callback interface just for the purpose of accessing a specific file resource. org.springframework.context.support.ApplicationObjectSupport is a convenience base class for application objects, implementing this interface. For a list of all bean lifecycle methods, see the BeanFactory javadocs." />
      <item value="Apply this BeanPostProcessor to the given new bean instance after any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original. In case of a FactoryBean, this callback will be invoked for both the FactoryBean instance and the objects created by the FactoryBean (as of Spring 2.0). The post-processor can decide whether to apply to either the FactoryBean or created objects or both through corresponding bean instanceof FactoryBean checks. This callback will also be invoked after a short-circuiting triggered by a InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation method, in contrast to all other BeanPostProcessor callbacks." />
      <item value="Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean * initialization callbacks (like InitializingBean's {@code afterPropertiesSet} * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original. * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean * instance and the objects created by the FactoryBean (as of Spring 2.0). The * post-processor can decide whether to apply to either the FactoryBean or created * objects or both through corresponding {@code bean instanceof FactoryBean} checks. * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method, * in contrast to all other BeanPostProcessor callbacks." />
    </histories>
  </component>
</application>