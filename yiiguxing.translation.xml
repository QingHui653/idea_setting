<application>
  <component name="AppStorage">
    <histories>
      <item value="recharge" />
      <item value="recharge Serial Number" />
      <item value="enter Receipt Order Info" />
      <item value="enter" />
      <item value="ente" />
      <item value="Deprecated" />
      <item value="abnormal" />
      <item value="abnormal Out" />
      <item value="IAreaService is not visible from class loader" />
      <item value="Loan Code (" />
      <item value="approval" />
      <item value="association" />
      <item value="collection" />
      <item value="set Delivered Money" />
      <item value="This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor)." />
      <item value="/** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */" />
      <item value="assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;" />
      <item value="Returns index for hash code h." />
      <item value="modeldto" />
      <item value="size" />
      <item value="threshold" />
      <item value="Callbacks to allow LinkedHashMap post-actions" />
      <item value="Val" />
      <item value="after Node Insertion" />
      <item value="treeify Bin" />
      <item value="preserve order" />
      <item value="Thr" />
      <item value="Tab" />
      <item value="evict" />
      <item value="Absent" />
      <item value="only If Absent" />
      <item value="the previous value associated with key, or null if there was no mapping for key. (A null return can also indicate that the map previously associated null with key.)" />
      <item value="if false, the table is in creation mode." />
      <item value="if true, don't change existing value" />
      <item value="The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds." />
      <item value="The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal." />
      <item value="The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage." />
      <item value="THRESHOLD" />
      <item value="The bin count threshold for using a tree rather than list for a bin. Bins are converted to trees when adding an element to a bin with at least this many nodes. The value must be greater than 2 and should be at least 8 to mesh with assumptions in tree removal about conversion back to plain bins upon shrinkage." />
      <item value="TREEIFY" />
      <item value="TREEIFY THRESHOLD" />
      <item value="Reclassify nodes in each list to new table. Because we * are using power-of-two expansion, the elements from * each bin must either stay at same index, or move with a * power of two offset. We eliminate unnecessary node * creation by catching cases where old nodes can be * reused because their next fields won't change. * Statistically, at the default threshold, only about * one-sixth of them need cloning when a table * doubles. The nodes they replace will be garbage * collectable as soon as they are no longer referenced by * any reader thread that may be in the midst of * concurrently traversing table. Entry accesses use plain * array indexing because they are followed by volatile * table write." />
      <item value="Clone remaining nodes" />
      <item value="Single node on list" />
      <item value="Mask" />
      <item value="size Mask" />
      <item value="/* * Reclassify nodes in each list to new table. Because we * are using power-of-two expansion, the elements from * each bin must either stay at same index, or move with a * power of two offset. We eliminate unnecessary node * creation by catching cases where old nodes can be * reused because their next fields won't change. * Statistically, at the default threshold, only about * one-sixth of them need cloning when a table * doubles. The nodes they replace will be garbage * collectable as soon as they are no longer referenced by * any reader thread that may be in the midst of * concurrently traversing table. Entry accesses use plain * array indexing because they are followed by volatile * table write. */" />
      <item value="given node to new table" />
      <item value="also adding the * given node to new table" />
      <item value="Doubles size of table and repacks entries, also adding the * given node to new table" />
    </histories>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
  </component>
</application>