<application>
  <component name="AppStorage">
    <histories>
      <item value="clear to let GC do its work" />
      <item value="min Capacity" />
      <item value="DEFAULT CAPACITY" />
      <item value="huge Capacity" />
      <item value="ELEMENTDATA" />
      <item value="EMPTY" />
      <item value="EMPTY ELEMENTDATA" />
      <item value="EOF Exception" />
      <item value="Utility methods for packing/unpacking primitive values in/out of byte arrays using big-endian byte ordering." />
      <item value="Bit Sieve" />
      <item value="Immutable arbitrary-precision integers. All operations behave as if BigIntegers were represented in two's-complement notation (like Java's primitive integer types). BigInteger provides analogues to all of Java's primitive integer operators, and all relevant methods from java.lang.Math. Additionally, BigInteger provides operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and a few other miscellaneous operations. Semantics of arithmetic operations exactly mimic those of Java's integer arithmetic operators, as defined in The Java Language Specification. For example, division by zero throws an ArithmeticException, and division of a negative by a positive yields a negative (or zero) remainder. All of the details in the Spec concerning overflow are ignored, as BigIntegers are made as large as necessary to accommodate the results of an operation. Semantics of shift operations extend those of Java's shift operators to allow for negative shift distances. A right-shift with a negative shift distance results in a left shift, and vice-versa. The unsigned right shift operator (&gt;&gt;&gt;) is omitted, as this operation makes little sense in combination with the &quot;infinite word size&quot; abstraction provided by this class. Semantics of bitwise logical operations exactly mimic those of Java's bitwise integer operators. The binary operators (and, or, xor) implicitly perform sign extension on the shorter of the two operands prior to performing the operation. Comparison operations perform signed integer comparisons, analogous to those performed by Java's relational and equality operators. Modular arithmetic operations are provided to compute residues, perform exponentiation, and compute multiplicative inverses. These methods always return a non-negative result, between 0 and (modulus - 1), inclusive. Bit operations operate on a single bit of the two's-complement representation of their operand. If necessary, the operand is sign- extended so that it contains the designated bit. None of the single-bit operations can produce a BigInteger with a different sign from the BigInteger being operated on, as they affect only a single bit, and the &quot;infinite word size&quot; abstraction provided by this class ensures that there are infinitely many &quot;virtual sign bits&quot; preceding each BigInteger. For the sake of brevity and clarity, pseudo-code is used throughout the descriptions of BigInteger methods. The pseudo-code expression (i + j) is shorthand for &quot;a BigInteger whose value is that of the BigInteger i plus that of the BigInteger j.&quot; The pseudo-code expression (i == j) is shorthand for &quot;true if and only if the BigInteger i represents the same value as the BigInteger j.&quot; Other pseudo-code expressions are interpreted similarly. All methods and constructors in this class throw NullPointerException when passed a null object reference for any input parameter." />
      <item value="Bean Context Child" />
      <item value="Bean Context" />
      <item value="Phantom reference objects, which are enqueued after the collector determines that their referents may otherwise be reclaimed. Phantom references are most often used for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism. If the garbage collector determines at a certain point in time that the referent of a phantom reference is phantom reachable, then at that time or at some later time it will enqueue the reference. In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The get method of a phantom reference always returns null. Unlike soft and weak references, phantom references are not automatically cleared by the garbage collector as they are enqueued. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable." />
      <item value="Phantom Reference" />
      <item value="Final references, used to implement finalization" />
      <item value="Invoked by VM" />
      <item value="/* Package-private; must be in same package as the Reference class */" />
      <item value="Malformed Parameterized Type Exception" />
      <item value="Invocation Target Exception" />
      <item value="Accessible Object" />
      <item value="ensure Capacity" />
      <item value="content Equals" />
      <item value="hibyte" />
      <item value="ascii" />
      <item value="The {@code double} value that is closer than any other to * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms." />
      <item value="A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system. Every Class object contains a reference to the ClassLoader that defined it. Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader. Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes. Class loaders may typically be used by security managers to indicate security domains. The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the &quot;bootstrap class loader&quot;, does not itself have a parent but may serve as the parent of a ClassLoader instance. Class loaders that support concurrent loading of classes are known as parallel capable class loaders and are required to register themselves at their class initialization time by invoking the ClassLoader.registerAsParallelCapable method. Note that the ClassLoader class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable. In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see loadClass methods). Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable. However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance. The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class. For example, an application could create a network class loader to download class files from a server. Sample code might look like: ClassLoader loader = new NetworkClassLoader(host, port); Object main = loader.loadClass(&quot;Main&quot;, true).newInstance(); . . . The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is: class NetworkClassLoader extends ClassLoader { String host; int port; public Class findClass(String name) { byte[] b = loadClassData(name); return defineClass(name, b, 0, b.length); } private byte[] loadClassData(String name) { // load the class data from the connection . . . } }" />
      <item value="Class Loader" />
      <item value="Thrown when the Java Virtual Machine detects a cir" />
      <item value="Class Circularity Error" />
      <item value="Char Sequence" />
      <item value="Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms." />
      <item value="Bootstrap" />
      <item value="Bootstrap Method Error" />
      <item value="Array Store Exception" />
      <item value="Arith" />
      <item value="metic" />
      <item value="Arithmetic Exception" />
      <item value="Class to track and run user level shutdown hooks registered through" />
      <item value="Maximum exponent a finite float variable may have. It is equal to the value returned by Math.getExponent(Float.MAX_VALUE)." />
      <item value="MAX EXPONENT" />
      <item value="A constant holding the smallest positive normal value of type float, 2-126. It is equal to the hexadecimal floating-point literal 0x1.0p-126f and also equal to Float.intBitsToFloat(0x00800000)." />
      <item value="MIN NORMAL" />
      <item value="NEGATIVE INFINITY" />
      <item value="POSITIVE INFINITY" />
      <item value="must cache" />
      <item value="Determines whether the specified code point is a valid Unicode code point value ." />
      <item value="is Valid Code Point" />
      <item value="SURROGATES AREA" />
      <item value="Unicode Block" />
    </histories>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>