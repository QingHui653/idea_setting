<application>
  <component name="AppStorage">
    <histories>
      <item value="Reclassify nodes in each list to new table. Because we * are using power-of-two expansion, the elements from * each bin must either stay at same index, or move with a * power of two offset. We eliminate unnecessary node * creation by catching cases where old nodes can be * reused because their next fields won't change. * Statistically, at the default threshold, only about * one-sixth of them need cloning when a table * doubles. The nodes they replace will be garbage * collectable as soon as they are no longer referenced by * any reader thread that may be in the midst of * concurrently traversing table. Entry accesses use plain * array indexing because they are followed by volatile * table write." />
      <item value="Clone remaining nodes" />
      <item value="Single node on list" />
      <item value="Mask" />
      <item value="size Mask" />
      <item value="/* * Reclassify nodes in each list to new table. Because we * are using power-of-two expansion, the elements from * each bin must either stay at same index, or move with a * power of two offset. We eliminate unnecessary node * creation by catching cases where old nodes can be * reused because their next fields won't change. * Statistically, at the default threshold, only about * one-sixth of them need cloning when a table * doubles. The nodes they replace will be garbage * collectable as soon as they are no longer referenced by * any reader thread that may be in the midst of * concurrently traversing table. Entry accesses use plain * array indexing because they are followed by volatile * table write. */" />
      <item value="given node to new table" />
      <item value="also adding the * given node to new table" />
      <item value="Doubles size of table and repacks entries, also adding the * given node to new table" />
      <item value="Scans for a node containing given key while trying to acquire lock, creating and returning one if not found. Upon return, guarantees that lock is held. UNlike in most methods, calls to method equals are not screened: Since traversal speed doesn't matter, we might as well help warm up the associated code and accesses as well." />
      <item value="re-traverse if entry changed" />
      <item value="MAX SCAN RETRIES" />
      <item value="a new node if key not found, else null" />
      <item value="Scans" />
      <item value="to recheck first below" />
      <item value="negative while locating node" />
      <item value="Gets the table entry for the given segment and hash" />
      <item value="use segment 0 as prototype" />
      <item value="ensure Segment" />
      <item value="recheck" />
      <item value="nonvolatile" />
      <item value="Returns the segment for the given index, creating it and recording in segment table (via CAS) if not already present." />
      <item value="Creates a new, empty map with the specified initial capacity, load factor and concurrency level." />
      <item value="create segments and segments[0]" />
      <item value="segment Shift" />
      <item value="Shift" />
      <item value="is Black 2" />
      <item value="body[6]=swapSellerOrderstatus2(purchaseOrdersDTO.getSellerOrderstatus()); //订单状态" />
      <item value="swap Seller Orderstatus 2" />
      <item value="body" />
      <item value="swap Delivevr 2" />
      <item value="seg" />
      <item value="mod Count" />
      <item value="null" />
      <item value="segment At" />
      <item value="/** * Creates a new, empty map with the specified initial capacity, * and with default load factor (0.75) and concurrencyLevel (16). * * @param initialCapacity the initial capacity. The implementation * performs internal sizing to accommodate this many elements. * @throws IllegalArgumentException if the initial capacity of * elements is negative. */" />
      <item value="/** * Creates a new, empty map with a default initial capacity (16), * load factor (0.75) and concurrencyLevel (16). */" />
      <item value="Creates a new, empty map with a default initial capacity (16), * load factor (0.75) and concurrencyLevel (16)." />
      <item value="Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result." />
      <item value="RETRIES BEFORE LOCK" />
      <item value="The maximum number of segments to allow; used to bound * constructor arguments. Must be power of two less than 1 &lt;&lt; 24." />
      <item value="1 &lt;&lt; 16" />
      <item value="MIN SEGMENT TABLE CAPACITY" />
      <item value="used when not * otherwise specified in a constructor." />
      <item value="The default concurrency level for this table" />
      <item value="DEFAULT CONCURRENCY LEVEL" />
      <item value="bucket Index" />
      <item value="bucket" />
      <item value="Access" />
      <item value="record" />
    </histories>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
  </component>
</application>